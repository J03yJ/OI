## 贪心

### ABC290G

$\tt\color{orange} Diff:2407$

#### 题目大意

给定一颗树高为 $D$ 的满 $K$ 叉树 $T$，问至少断开几条边才能使某一连通块的大小为 $X$。

数据范围：

- $\displaystyle1\leq X\leq \sum_{i=0}^DK^i\leq10^{18}$

#### 题解

枚举连通块的根的树高 $D'$，使得 $D'\leq D$ 且 $\displaystyle X\leq \sum_{i=0}^DK^i$。

那么我们还要丢掉 $C=-X+\sum_{i=0}^DK^i$ 个节点，可以贪心地删除尽量大的子树。

最后取最小值即可。

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long

signed main(){
    int T;
    cin>>T;
    while(T--){
        int n,m,k;
        cin>>n>>k>>m;
        
        int p=0,q=1,ans=2e18;
        while(q<m) p++,q*=k,q++;
        for(;p<=n;p++,q=q*k+1){
            int tmp=q-m,res=(p!=n);
            for(int i=p,pw=q;~i;i--,pw/=k){
                int j=tmp/pw;
                tmp-=j*pw;
                res+=j;
            }
            ans=min(ans,res);
        }

        cout<<ans<<endl;
    }

    return 0;
}
```

## 构造

### ARC139C

$\tt\color{orange} Diff:2406$

#### 题目大意

给定 $N$ 和 $M$，构造尽可能多的数对 $(X_i,Y_i)$ 使得：

- $X_i\leq N$ 且 $Y_i\leq M$。
- 不存在 $i,j$ 使得 $3X_i+Y_i=3X_j+Y_j$ 或 $X_i+3Y_i=X_j+3Y_j$。

数据范围：

- $N,M\leq 10^5$

#### 题解

这怎么想啊 QAQ。

不失一般性的，令 $N\leq M$。考虑将 $(X_i,Y_i)$ 投射到 $N\times M$ 的矩形上，要求变为不存在两点同在一条斜率为 $3$ 或 $\frac 13$ 的直线上。

令 $3X_i+Y_i=K$，则 $K$ 的取值范围是 $[4,3N+M]$，所以最多有 $3N+M-3$ 个数对。这个上界在 $N\neq M$ 或 $N$ 为奇数时可以取到，一种构造方式（官解）如下：

```
oooxxxxx
oooxxxxx
oooooxxx
xxoooxxx
xxoooooo
```

而在剩下的情况中，上界为 $3N+M-4$，依然可以如法炮制：

```
oooxxx
oooxxx
ooooox
xxooox
xxoooo
xxxxoo
```

发现少了一个的原因是 $(N+1,M-1)$ 是非法的。

模拟即可，时间复杂度 $O(N)$。

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

int n,m,x=1,y=0,fl;
vector<pair<int,int>> ans;
void F(){
    y++;
    if(x<=n&&y<=m&&x>=1&&y>=1) ans.push_back({x,y});
}
void B(){
    x++,y-=2;
    if(x<=n&&y<=m&&x>=1&&y>=1) ans.push_back({x,y});
}

int main(){
    cin>>n>>m;
    if(n>m) swap(n,m),fl=1;
    while(x!=n){
        F(),F(),F(),B();
        if(x==n) break ;
        F(),F(),B();
        if(x==n) break ;
        F();
    }
    while(y<m) F();
    cout<<ans.size()<<endl;
    if(!fl) for(auto p:ans) cout<<p.first<<' '<<p.second<<endl;
    else for(auto p:ans) cout<<p.second<<' '<<p.first<<endl;

    return 0;
}
```

### AGC065C

#### 题目大意

给定一个长为 $N$ 的数组 $A$，判断是否存在数列 $B,C$ 满足：

- $\forall i=[1,N]$，有 $B_i+C_i=A_i$。
- 不存在一个数组 $X$ 满足 $\forall i\in[1,n],X_i\in \{B_i,C_i\}$，使得 $\displaystyle \sum_{i=1}^n X_i=\frac 12\sum_{i=1}^n A_i$ 。

数据范围：

- $A_i\leq 2\times10^5$

- $\sum A_i$ 是偶数。

#### 题解

我超，超级结论题！

发现 $\displaystyle \sum_{i=1}^n X_i=\frac 12\sum_{i=1}^n A_i$ 等价于 $\displaystyle \sum_{i=1}^n (A_i-X_i)-X_i=0$，也就是说，如果把这个过程看成博弈，那么目的就是令 ${B_i,C_i}$ 不能分成和相等的两堆。

贪心地，我们肯定希望最后两堆的差尽量大，于是我们会令某一对较大的为 $B_i=A_i,C_i=0$，而剩下的若干对的差为 $0$（偶数）或 $1$（奇数）。然而，直接选取最大值可能会使程序面对形如 `1 3 3 3` 的数据出问题。原因在于较大的可能不止一对。故枚举所谓的「较大值」$k$，将大于等于 $k$ 的数分成偶数对差为 $k$ 的值，将小于 $k$ 的分为若干对 $0$ 或 $1$。

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define ssiz(x) (signed)x.size()

int main(){
    int T;
    cin>>T;
    while(T--){
        int n;
        cin>>n;
        vector<int> a,b;
        while(n--){
            int x;
            cin>>x;
            if(x&1) a.push_back(x);
            else b.push_back(x);
        }
        sort(a.begin(),a.end());
        sort(b.begin(),b.end());

        if(ssiz(b)&&b.back()>ssiz(a)){
            cout<<"Yes"<<endl;
            continue ;
        }
        int flag=0;
        for(int i=0;i<ssiz(a);i++){
            int tot=ssiz(a)-i;
            if(tot&1){
                if(a[i]>i){
                    cout<<"Yes"<<endl;
                    flag=1;
                    break ;
                }
            }
        }
        if(!flag) cout<<"No"<<endl;
    }

    return 0;
}
```

