## 数论

### ABC137F

$\tt\color{orange} Diff:2402$

#### 题目大意

给定一个质数 $p$，求一个 $p-1$ 次的多项式 $p$ 使得 $\forall i\in[0,p-1]$，有 $f(i)=a_i$。

数据范围：

- $2\leq p\leq 2999$
- $0\leq a_i\leq 1$

#### 题解

喵喵题。

第一眼首先想到插值，但是好像不太现实。

发现 $p$ 是质数，于是根据费马小定理有：

- $(a-b)^{p-1}\equiv\left\{\begin{matrix} 0&a=b \\ 1&a\neq b \end{matrix}\right.$

所以可以想到一个满足条件的多项式 $\displaystyle f(x)=\sum_{i=1}^n a_i[1-(x-i)^{p-1}]$。

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=3e3+9;

int c[N][N],a[N],ans[N],n;

int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    for(int i=0;i<=n;i++){
        c[i][0]=1;
        for(int j=1;j<=i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%n;
    }
    for(int i=0;i<n;i++){
        if(!a[i]) continue ;
        ans[0]=(ans[0]+a[i])%n;
        for(int j=n-1,pw=1;~j;j--,pw=pw*(n-i)%n){
            ans[j]=(ans[j]+c[n-1][j]*(n-a[i])%n*pw%n)%n;
        }
    }
    for(int i=0;i<n;i++) cout<<ans[i]<<' ';cout<<endl;

    return 0;
}
```

### ARC182C

$\tt\color{orange} Diff:2408$

#### 题目大意

给定 $K$ 和 $M$，求 $\displaystyle \sum_{|A|\leq K,A_i\in[1,M]} d(\prod_{i=1}^{|A|}A_i)$。

数据范围：

- $M\leq 16$
- $K\leq 10^{18}$

#### 题解

令 $\displaystyle n=|A|,\prod_{i=1}^n A_i=\prod p_j^{a_j}$，则 $\displaystyle  d(\prod_{i=1}^n A_i)=\prod (a_j+1)$。

假设当前加入了一个数 $\displaystyle x=\prod p_i^{b_i}$，则答案更新为 $\displaystyle \prod (a_i+b_i+1)$。

考虑枚举集合拆贡献，则原式变为：$\displaystyle \sum_S \prod_{i\in S} (a_i+1) \prod_{i\notin S} b_i$。

更进一步的，令 $f_S$ 为所有情况中仅保留 $S$ 中的素数的答案，即 $f_S=\displaystyle \sum_A \prod_{i\in S} (a_i+1)$。

则新增 $x$ 后的 $f'_S$ 可以由 $f$ 递推得：$\displaystyle f'_S=\sum_{x=1}^M\sum_{T\subseteq S} f_S \prod_{i\in S-T} b_i$。

发现后面可以预处理，并且 $S$ 状压后的值域只有 $64$，于是想到矩阵快速幂，同时因为求的是前缀 $f_{U}$ 所以多开一位记录答案。具体的，令 $X=\begin{bmatrix} 1\\ \vdots \\ 1 \end{bmatrix}$，$A$ 为一个 $2^{\pi(M)}\times 2^{\pi(M)}$ 的矩阵，且 $B_{S,T}=\displaystyle \sum_{x=1}^M \prod_{i\in S-T} b_i$，则答案为 $B^KX$ 答案位上的值，时间复杂度为 $O(8^{\pi(n)}\log K)$。

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long
const int P=6;
const int M=(1<<P)+1;
const int p[P]={2,3,5,7,11,13};
const int mod=998244353;
const int N=16;

int cnt[N][P],f[M][M],g[M][M],m,k;

void MulAs(int f[M][M],int g[M][M]){
    int h[M][M];
    for(int i=0;i<M;i++){
        for(int j=0;j<M;j++){
            h[i][j]=0;
            for(int k=0;k<M;k++) h[i][j]=(h[i][j]+f[i][k]*g[k][j]%mod)%mod;
        }
    }
    memcpy(f,h,sizeof h);
}
void QPowAs(int x[M][M],int y){
    int h[M][M];
    memset(h,0,sizeof h);
    for(int i=0;i<M;i++) h[i][i]=1;
    while(y){
        if(y&1) MulAs(h,x);
        MulAs(x,x);
        y>>=1;
    }
    memcpy(x,h,sizeof h);
}

signed main(){
    cin>>k>>m;
    for(int i=1;i<=m;i++){
        int tmp=i;
        for(int j=0;j<P;j++){
            while(tmp%p[j]==0) tmp/=p[j],cnt[i][j]++;
        }
    }

    for(int i=1;i<=m;i++){
        for(int sta=0;sta<(1<<P);sta++){
            for(int tta=sta;;tta=(tta-1)&sta){
                int tmp=1;
                for(int j=0;j<P;j++) if((tta>>j)&1) tmp=tmp*cnt[i][j]%mod;
                f[sta^tta][sta]=(f[sta^tta][sta]+tmp)%mod;
                if(!tta) break ;
            }
        }
    }
    f[1<<P][1<<P]=f[(1<<P)-1][1<<P]=1;
    QPowAs(f,k);
    for(int i=0;i<(1<<P);i++) g[0][i]=1;
    MulAs(g,f);

    cout<<(g[0][1<<P]+g[0][(1<<P)-1]-1)%mod<<endl;

    return 0;
}
```

## 期望

### ARC150D

$\tt\color{orange} Diff:2407$

#### 题目大意

给定一颗树，每个点都有黑白两种颜色之一，初始均为白色。定义好点是到根节点路径上全为黑色的点，每次操作会选择一个坏点涂黑，求将整颗树涂黑的期望操作数。

数据范围：

- $N\leq 2\times 10^5$

#### 题解

令一个节点 $u$ 被选中了 $f(u)$ 次，那么答案即为 $\displaystyle \sum_u f(u)$。同时令所有节点均可以被选中涂黑，此时坏节点的代价为 $1$，好节点的代价为 $0$，不难发现答案是一样的。

发现若节点 $u$ 为好的，当且仅当 $1$ 到 $u$ 的 $d_u$ 个节点全为黑色，即全被选中过。那么归类到集邮抽卡问题，期望操作次数为 $nH(d_u)$。同时因为所有节点是等概率选择的，选中 $u$ 的次数为 $\frac 1n\cdot nH(d
_u)=H(d_u)$，所以最终答案即为 $\displaystyle \sum_u H(d_u)$。

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long
const int mod=998244353;

int QPow(int x,int y){
    int res=1;
    while(y){
        if(y&1) res=res*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return res;
}

signed main(){
    int n;
    cin>>n;
    vector<int> a(n+1,0),d(n+1,0),H(n+1,0);
    d[1]=1;
    for(int i=2;i<=n;i++) cin>>a[i],d[i]=d[a[i]]+1;

    int ans=0;
    for(int i=1;i<=n;i++) H[i]=(H[i-1]+QPow(i,mod-2))%mod;
    for(int i=1;i<=n;i++) ans=(ans+H[d[i]])%mod;

    cout<<ans<<endl;

    return 0;
}
```

### ABC352G

$\tt\color{orange} Diff:2413$

#### 题目大意

给定 $N$ 种袜子，第 $i$ 种有 $A_i$ 个，每次等概率取出一只袜子，求取出两种相同的袜子的期望步数。

数据范围：

- $N\leq 3\times 10^5$
- $A_i\leq 3\times 10^3$
- $\rm time:3s$

#### 题解

正难则反，不难发现最多取出 $N+1$ 只袜子，令 $P_i$ 表示至少取出 $i$ 只袜子的概率，则答案为 $\displaystyle \sum P_i$。

形式化的，令 $a=\displaystyle \sum_{i=1}^N A_i$，取出至少 $i$ 只不同的袜子的概率为 $P_{i+1}=\displaystyle \frac1{C_a^i}\sum_{|S|=i}\prod_{j\in S}A_j$，也就是说，$\displaystyle P_{i+1}=\frac1{C_a^i}[x^i]\prod(A_ix+1)$。

这是一个很经典的式子，可以使用分治 NTT 解决，时间复杂度 $O(N\log^2N)$。

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long
#define ssiz(x) (signed)x.size()
const int N=3e5+9;
const int mod=998244353;
int QPow(int x,int y){
    int res=1;
    while(y){
        if(y&1) res=res*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return res;
}
#define Inv(x) QPow(x,mod-2)

const int gmod=3;
const int invg=Inv(gmod);
using Poly=vector<int>;

void NTT(Poly &f,Poly &r,int lim,int flag){
    for(int i=0;i<lim;i++) if(i<r[i]) swap(f[i],f[r[i]]);
    for(int k=1;k<lim;k<<=1){
        int len=k<<1,gn=QPow(flag>0?gmod:invg,(mod-1)/len);
        for(int i=0;i<lim;i+=len){
            for(int j=0,g=1;j<k;j++,g=g*gn%mod){
                int tmp=f[i+j+k]*g%mod;
                f[i+j+k]=(f[i+j]-tmp+mod)%mod;
                f[i+j]=(f[i+j]+tmp)%mod;
            }
        }
    }
    if(!~flag){
        int inv=Inv(lim);
        for(int &x:f) x=x*inv%mod;
    }
}
Poly Mul(Poly f,Poly g){
    int len=ssiz(f)+ssiz(g)-1,lim=1;
    while(lim<len) lim<<=1;
    f.resize(lim,0),g.resize(lim,0);

    Poly rev(lim,0),h(lim,0);
    for(int i=0;i<lim;i++){
        rev[i]=rev[i>>1]>>1;
        if(i&1) rev[i]|=lim>>1;
    }
    NTT(f,rev,lim,1),NTT(g,rev,lim,1);
    for(int i=0;i<lim;i++) h[i]=f[i]*g[i]%mod;
    NTT(h,rev,lim,-1);

    h.resize(len,0);
    return h;
}

int a[N],n;
Poly F(int l,int r){
    if(l==r) return {1,a[l]};
    int mid=(l+r)>>1;
    return Mul(F(l,mid),F(mid+1,r));
}

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    #define endl '\n'

    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];

    int sum=0;
    for(int i=1;i<=n;i++) sum+=a[i];
    vector<int> C(n+1,0);
    C[0]=1;for(int i=1;i<=n;i++) C[i]=C[i-1]*(sum-i+1)%mod*Inv(i)%mod;

    int ans=0;
    Poly f=F(1,n);
    for(int i=0;i<=n;i++) ans=(ans+f[i]*Inv(C[i])%mod)%mod;
    cout<<ans<<endl;

    return 0;
}
```
