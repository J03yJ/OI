# IOI 2026 å›½å®¶é›†è®­é˜Ÿä½œä¸šæ•´ç†

## é¢˜ç›®æ•´ç†

### 1. Cells Blocking

é¦–å…ˆå¦‚æœ $(1,1)$ å’Œ $(n,m)$ ä¸è¿é€šï¼Œé‚£ä¹ˆæ–¹æ¡ˆæ•°å°±æ˜¯ $\dbinom c2$ï¼Œå…¶ä¸­ $c$ æ˜¯ç©ºåœ°ä¸ªæ•°ã€‚

å¦‚æœ $(1,1)$ å’Œ $(n,m)$ æœ¬å°±è”é€šï¼Œé‚£ä¹ˆä¸¤ä¸ªé€‰å–çš„ç‚¹å¿…ç„¶è‡³å°‘æœ‰ä¸€ä¸ªåœ¨æœ€å·¦ä¸‹è·¯å¾„ä¸Šã€‚è€ƒè™‘æšä¸¾è¿™ä¸ªç‚¹ï¼Œè®¾ä¸º $(x,y)$ï¼Œé‚£ä¹ˆå¦ä¸€ä¸ªç‚¹å°±æ˜¯æ–°å›¾ä¸­ $(1,1)$ åˆ° $(n,m)$ çš„å¿…ç»ç‚¹ï¼Œè€Œä» $(1,1)$ åˆ° $(n,m)$ å¿…ç»çš„ç‚¹ä¸€å®šæ˜¯æœ€å·¦ä¸‹çš„è·¯å¾„å’Œæœ€å³ä¸Šçš„è·¯å¾„çš„äº¤ç‚¹ã€‚å‡è®¾å›¾ä»è”é€šï¼Œé‚£ä¹ˆæœ€å³ä¸Šè·¯å¾„ä¸å˜ï¼Œè€ƒè™‘å¦‚ä½•æ‰¾åˆ°æ–°çš„æœ€å·¦ä¸‹è·¯å¾„ã€‚ç”±äºæ¯æ¡è·¯å¾„ $x+y=c$ ä¸Šåªä¼šæ°å¥½é€‰ä¸€ä¸ªç‚¹ï¼Œå› æ­¤æ‰¾åˆ°æœ€å°çš„ $k$ ä½¿å¾— $(x-k,y+k)$ ä»èƒ½åˆ°è¾¾ $(1,1)$ å’Œ $(n,m)$ï¼Œæ‰¾å‡ºå…¶åˆ° $(1,1)$ å’Œ $(n,m)$ çš„æœ€å·¦ä¸‹è·¯å¾„å¹¶æ‹¼æ¥èµ·æ¥å°±æ˜¯æ–°çš„æœ€å·¦ä¸‹è·¯å¾„ã€‚å’Œæœ€å³ä¸Šè·¯å¾„å½’å¹¶å³å¯æ‰¾å‡ºæ‰€æœ‰äº¤ç‚¹ã€‚æ—¶é—´å¤æ‚åº¦ $O((n+m)^2)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=3e3+9;

int ban[N][N],n,m;
char a[N][N],lu[N][N],rd[N][N];
inline bool Valid(char c[N][N],int i,int j){return c[i][j]!='*'&&c[i][j];}
template<class T> inline int Merge(vector<T> u,vector<T> v){
	int cnt=0;
	while(u.size()){
		while(v.size()&&v.back()>u.back()) v.pop_back();
		if(v.size()&&v.back()==u.back()) cnt+=!ban[v.back()[0]][v.back()[1]];
		u.pop_back();
	}
	return cnt;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin>>a[i][j];
	}

	int cnt=0;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cnt+=(a[i][j]=='.');
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='*') lu[i][j]='*';
			else if(i==1&&j==1) lu[i][j]='.';
			else if(Valid(lu,i,j-1)||Valid(lu,i-1,j)) lu[i][j]='~';
			else lu[i][j]='*';
		}
	}
	for(int i=n;i>=1;i--){
		for(int j=m;j>=1;j--){
			if(a[i][j]=='*') ;
			else if(i==n&&j==m) rd[i][j]='.';
			else if(Valid(rd,i,j+1)||Valid(rd,i+1,j)) rd[i][j]='~';
			else rd[i][j]='*';
		}
	}

	if(!Valid(rd,1,1)){
		cout<<1ll*cnt*(cnt-1)/2<<endl;
		return 0;
	}

	vector<array<int,2>> rp;
	for(int i=1,j=1;;){
		rp.push_back({i,j});
		if(rd[i][j]=='.') break ;
		else if(Valid(rd,i,j+1)) j++;
		else if(Valid(rd,i+1,j)) i++;
	}

	ll ans=0,c=0;
	for(int i=1,j=1;;){
		int k=1;
		while(i-k>=1&&j+k<=m&&(!Valid(lu,i-k,j+k)||!Valid(rd,i-k,j+k))) k++;
		if(i-k<1||j+k>m) ans+=cnt-c-1;
		else{
			vector<array<int,2>> lp;
			for(int p=i-k,q=j+k;;){
				lp.push_back({p,q});
				if(lu[p][q]=='.') break ;
				else if(Valid(lu,p,q-1)) q--;
				else if(Valid(lu,p-1,q)) p--;
			}
			reverse(lp.begin(),lp.end());
			lp.pop_back();
			for(int p=i-k,q=j+k;;){
				lp.push_back({p,q});
				if(rd[p][q]=='.') break ;
				else if(Valid(rd,p+1,q)) p++;
				else if(Valid(rd,p,q+1)) q++;
			}
			ans+=Merge(lp,rp);
		}
		c++;
		ban[i][j]=1;
		if(rd[i][j]=='.') break ;
		else if(Valid(rd,i+1,j)) i++;
		else if(Valid(rd,i,j+1)) j++;
	}
	
	cout<<ans<<endl;

	return 0;
}
```

### 2. Giant Penguin

è€ƒè™‘å»ºå‡ºç‚¹åˆ†æ ‘ï¼Œé‚£ä¹ˆä¸€æ¡è·¯å¾„è¦ä¹ˆè·¨è¿‡åˆ†æ²»ä¸­å¿ƒï¼Œè¦ä¹ˆè·¨è¿‡ä¸€ä¸ªè·¨è¿‡åˆ†æ²»ä¸­å¿ƒçš„æ¨ªå‰è¾¹ã€‚ç”±äºè¿™ç§æ¨ªå‰è¾¹å¯ä»¥å’Œåˆ†æ”¯ä¸­å¿ƒæ„æˆä¸€ä¸ªç®€å•ç¯ï¼Œå› æ­¤è¿™ç§è¾¹ä¸ä¼šè¶…è¿‡ $k$ æ¡ã€‚è€ƒè™‘ç”¨ BFS é¢„å¤„ç†å­æ ‘å†…å„ä¸ªèŠ‚ç‚¹åˆ°åˆ†æ²»ä¸­å¿ƒä»¥åŠå„ä¸ªæ¨ªå‰è¾¹ä¹‹é—´çš„è·ç¦»ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„ä¿¡æ¯åˆ™å¯ä»¥åŠ¨æ€ç»´æŠ¤ï¼Œæ—¶é—´å¤æ‚åº¦ $O((n+q)k\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=2e5+9;
const int K=1e1+9;
const int lgN=2e1;

int typ[N],n,m,k,q;
vector<array<int,2>> e[N];

int vis[N];
inline void GetTE(int x){
	vis[x]=1;
	for(auto p:e[x]){
		if(!vis[p[0]]){
			typ[p[1]]=1;
			GetTE(p[0]);
		}
	}
}
int mrk[N],siz[N];
inline void GetGrv(int x,int fa,int tot,int &grv){
	bool err=0;
	siz[x]=1;
	for(auto p:e[x]){
		if(p[0]==fa) continue ;
		if(mrk[p[0]]) continue ;
		if(typ[p[1]]!=1) continue ;
		GetGrv(p[0],x,tot,grv);
		siz[x]+=siz[p[0]];
		err|=(siz[p[0]]>tot/2);
	}
	err|=(tot-siz[x]>tot/2);
	if(!err) grv=x;
}
int col[N],cp[N];
inline void Color(int x,int fa,int c,int rt,vector<int> &v){
	col[x]=c,cp[x]=rt;
	v.push_back(x);
	for(auto p:e[x]){
		if(p[0]==fa) continue ;
		if(mrk[p[0]]) continue ;
		if(typ[p[1]]!=1) continue ;
		Color(p[0],x,c,rt,v);
	}
}
int dep[lgN][K][N],mn[N][K];
inline void BFS(int s,int *dep){
	dep[s]=0;
	queue<int> q;
	q.push(s);
	while(q.size()){
		int x=q.front();
		q.pop();
		for(auto p:e[x]){
			if(mrk[p[0]]) continue ;
			if(!~typ[p[1]]) continue ;
			if(dep[x]+1<dep[p[0]]){
				dep[p[0]]=dep[x]+1;
				q.push(p[0]);
			}
		}
	}
}
int d[N],up[N],ec[N];
inline void Conquer(int x,int tot,int u){
	GetGrv(x,-1,tot,x);
	GetGrv(x,-1,tot,x);
	up[x]=u,d[x]=d[u]+1;

	int ccnt=0;
	vector<int> sv;
	col[x]=0,cp[x]=x;
	for(auto p:e[x]){
		if(mrk[p[0]]) continue ;
		if(typ[p[1]]!=1) continue ;
		Color(p[0],x,++ccnt,x,sv);
	}
	for(int y:sv){
		for(auto p:e[y]){
			if(mrk[p[0]]) continue ;
			if(typ[p[1]]) continue ;
			if(cp[p[0]]!=x) continue ;
			if(col[p[0]]<=col[y]) continue ;
			BFS(y,dep[d[x]][++ec[x]]);
			typ[p[1]]=-1;
		}
	}
	BFS(x,dep[d[x]][++ec[x]]);

	mrk[x]=1;

	for(auto p:e[x]){
		if(mrk[p[0]]) continue ;
		if(typ[p[1]]!=1) continue ;
		Conquer(p[0],siz[p[0]],x);
	}
}

inline void Update(int x){
	for(int y=x;y;y=up[y]){
		for(int i=1;i<=ec[y];i++) mn[y][i]=min(mn[y][i],dep[d[y]][i][x]);
	}
}
inline int Calc(int x){
	int ans=1e9;
	for(int y=x;y;y=up[y]){
		for(int i=1;i<=ec[y];i++) ans=min(ans,mn[y][i]+dep[d[y]][i][x]);
	}
	return ans;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m>>k;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		e[u].push_back({v,i});
		e[v].push_back({u,i});
	}

	memset(mn,0x3f,sizeof mn);
	memset(dep,0x3f,sizeof dep);
	GetTE(1);
	Conquer(1,n,0);

	cin>>q;
	while(q--){
		int op,x;
		cin>>op>>x;
		if(op==1) Update(x);
		else cout<<Calc(x)<<endl;
	}

	return 0;
}
```

### 3. Edit Distance Yet Again

é¦–å…ˆæŠŠ $O(n^2)$ çš„ DP è¿‡ç¨‹æ”¾åˆ°å¹³é¢ä¸Šè€ƒè™‘ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±å˜æˆäº† $S=(1,1)$ åˆ° $T=(n+1,m+1)$ çš„æœ€çŸ­è·¯ã€‚

æœ‰ä¸€ä¸ªå…³é”®æ€§è´¨æ˜¯ï¼Œå¯¹äº $d(S\rightarrow(i,i+\Delta))=d(S\rightarrow(j,j+\Delta))$ çš„ $i<j$ å’Œ $\Delta$ï¼Œä» $(i,i+\Delta)$ è½¬ç§»ä¸€å®šä¸ä¼˜ã€‚

è¯æ˜è€ƒè™‘ $(i,i+\Delta)$ è·¯å¾„ä¸Šçš„ç‚¹ $(j,k)$ï¼Œå…¶ä¸­ $k\geq j+\Delta$ï¼Œé‚£ä¹ˆ $d((j,j+\Delta)\rightarrow(j,k))\leq d((i,i+\Delta)\rightarrow(j,k))$ï¼Œæ‰€ä»¥ $(j,j+\Delta)$ æ›´ä¼˜ã€‚å¦‚æœä¸å­˜åœ¨ $(j,k)$ åˆ™å¯ä»¥ç”¨ $(k,j+\Delta)$ ç±»ä¼¼åœ°è¯æ˜ï¼Œå› ä¸º $(j,k)$ å’Œ $(k,j+\Delta)$ ä¸€å®šè‡³å°‘å­˜åœ¨ä¸€ä¸ªã€‚

å°†æ‰€æœ‰è¿™æ ·çš„ç‚¹ç¼©åœ¨ä¸€èµ·ä¹‹åï¼Œæœ‰æ•ˆçŠ¶æ€æ•°å°±æ˜¯ $O(k^2)$ çš„ï¼ŒåŸç†æ˜¯ $0 \leq d(S\rightarrow (i,i+\Delta)) \leq k$ï¼Œè€Œ $-k \leq \Delta \leq k$ã€‚æ‰¾åˆ°ä¸€ç»„ $(d,\Delta)$ æœ€æœ‰ç”¨çš„ $i$ å¯ä»¥ç›´æ¥æŸ¥è¯¢åç¼€çš„ LCPï¼Œä¸€å±‚ä¸€å±‚åœ°è½¬ç§»å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ $O((n+k^2) \log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
using ull=unsigned long long;
using bint=__int128;
const int N=2e6+9;
const int K=1e3+9;
const int lgN=2e1;
const ll mod=114514191981000001ll;
const ll base=1000;

inline void AddAs(ll &x,ll y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(ll &x,ll y){if((x-=y)<0) x+=mod;}
inline void MulAs(ll &x,ll y){x=bint(x)*y%mod;}
inline ll Add(ll x,ll y){if((x+=y)>=mod) x-=mod;return x;}
inline ll Sub(ll x,ll y){if((x-=y)<0) x+=mod;return x;}
inline ll Mul(ll x,ll y){return bint(x)*y%mod;}
inline ll QPow(ll x,ll y){
	ll res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
inline ll Inv(ll x){return QPow(x,mod-2);}

int n,m,k;
char s[N],t[N];
ll hs[N],ht[N],b[N],ib[N];
inline void Init(int lim){
	const ll ibase=Inv(base);
	ib[0]=b[0]=1;
	for(int i=1;i<=lim;i++){
		b[i]=Mul(b[i-1],base);
		ib[i]=Mul(ib[i-1],ibase);
	}
}
inline void CalcHash(char *s,ll *h,int n){
	for(int i=1;i<=n;i++) h[i]=Add(h[i-1],Mul(s[i],b[i-1]));
}
inline ll H(ll *h,int l,int r){return Mul(Sub(h[r],h[l-1]),ib[l-1]);}
inline int LCP(int i,int j){
	int l=0,r=min(n-i+1,m-j+1)+1;
	while(l+1<r){
		int mid=l+r>>1;
		if(H(hs,i,i+mid-1)==H(ht,j,j+mid-1)) l=mid;
		else r=mid;
	}
	return l;
}

int cnt=0;
const int dx[3]={1,0,1};
const int dy[3]={0,1,1};
int id[K][K<<1],pre[K][K<<1];
inline ull F(unsigned x,unsigned y){return (ull(x)<<23)^(ull(x)<<13)^(ull(x)<<3)^y;}
inline ull F(array<int,2> x){return F(x[0],x[1]);}
inline void Solve(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) cin>>s[i];
	for(int i=1;i<=m;i++) cin>>t[i];

	Init(max(n,m));
	CalcHash(s,hs,n);
	CalcHash(t,ht,m);
	
	auto T=[](array<int,2> p)->array<int,2>{
		int k=LCP(p[0],p[1]);
		return {p[0]+k,p[1]+k};
	};
	for(int i=0;i<=k;i++){
		for(int j=-k;j<=k;j++) id[i][K+j]=pre[i][K+j]=-1;
	}
	int p=-1;
	id[0][K+0]=1+LCP(1,1);
	for(int r=0;r<=k;r++){
		for(int d=-k;d<=k;d++){
			int i=id[r][K+d],j=i-d;
			if(!~i) continue ;
			if(i==n+1&&j==m+1){
				p=r;
				break ;
			}
			for(int o:{0,1,2}){
				if(i+dx[o]>n+1||j+dy[o]>m+1) continue ;
				array<int,2> nxt=T({i+dx[o],j+dy[o]});
				int u=nxt[0],v=nxt[1];
				if(u>id[r+1][K+u-v]){
					id[r+1][K+u-v]=u;
					pre[r+1][K+u-v]=i-j;
				}
			}
		}
		if(~p) break ;
	}

	if(~p){
		cout<<"YES"<<endl;
		cout<<p<<endl;
		vector<tuple<string,int,char>> ans;
		for(int r=p,i=n+1,j=m+1;r>=1;r--){
			int u=id[r-1][K+pre[r][K+i-j]],v=u-pre[r][K+i-j];
			if(!~u) break ;
			int dlt=(i-u)-(j-v);
			if(dlt==0) ans.push_back({"REPLACE",v,t[v]});
			else if(dlt==1) ans.push_back({"DELETE",v,'#'});
			else ans.push_back({"INSERT",v,t[v]});
			i=u,j=v;
		}
		reverse(ans.begin(),ans.end());
		for(auto t:ans){
			if(get<0>(t)=="DELETE") cout<<get<0>(t)<<' '<<get<1>(t)<<endl;
			else cout<<get<0>(t)<<' '<<get<1>(t)<<' '<<get<2>(t)<<endl;
		}
	}else cout<<"NO"<<endl;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int T;
	cin>>T;
	while(T--) Solve();

	return 0;
}
```

### 4. Cactus

ğŸŒµğŸŒµï¼Ÿï¼

é¦–å…ˆåªæœ‰ä¸€ä¸ªç¯æ˜¯ç»å…¸ DP é—®é¢˜ã€‚

å‘ç°æŠŠä»™äººæŒç¼©æˆæ ‘ä¹‹åç›¸å½“äºå¯¹éæ ¹çš„ç¯ä¸Šæœ€é«˜ç‚¹ ban æ‰ä¸€ç§é¢œè‰²ï¼Œå³ä»£ä»·ä¹˜ä¸Š $\dfrac {k}{k-1}$ã€‚

ç„¶ååˆèµ·æ¥å°±ğŸŒµå®Œäº†ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=4e5+9;
const int mod=1e9+7;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
inline int Inv(int x){return QPow(x,mod-2);}

vector<int> e[N],stk;
int dfn[N],low[N],ins[N],bel[N],len[N],f[N][2],g[N],n,m,k,dcnt,scnt;
inline void Tarjan(int x,int fa){
	ins[x]=1;
	stk.push_back(x);
	dfn[x]=low[x]=++dcnt;
	for(int y:e[x]){
		if(y==fa) continue ;
		if(!dfn[y]){
			Tarjan(y,x);
			low[x]=min(low[x],low[y]);
		}else if(ins[y]) low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		scnt++;
		while(stk.size()){
			int p=stk.back();
			stk.pop_back();
			bel[p]=scnt;
			len[scnt]++;
			ins[p]=0;
			if(p==x) break ;
		}
	}
}
inline void Solve(){
	cin>>n>>m>>k;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	
	Tarjan(1,0);

	f[1][0]=0,f[1][1]=1;
	for(int i=2;i<=n;i++){
		f[i][0]=Add(Mul(f[i-1][0],k-2),Mul(f[i-1][1],k-1));
		f[i][1]=f[i-1][0];
	}
	for(int i=1;i<=n;i++) g[i]=f[i][i==1];

	int ans=1;
	for(int i=1;i<=scnt;i++) MulAs(ans,Mul(k-1,g[len[i]]));
	MulAs(ans,Mul(k,Inv(k-1)));

	cout<<ans<<endl;

	dcnt=scnt=0;
	for(int i=1;i<=n;i++){
		e[i].clear();
		dfn[i]=low[i]=ins[i]=bel[i]=len[i]=0;
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int T;
	cin>>T;
	while(T--) Solve();

	return 0;
}
```

### 6. Social Justice

å¹³å‡å€¼å‡ ä¹æ²¡æœ‰ä»»ä½•æ€§è´¨ã€‚

é¦–å…ˆæ’å®ŒåºäºŒåˆ†ä¸€ä¸‹å°±å¯ä»¥æ‰¾å‡ºæœ€å¤šå‰©å‡ ä¸ªäººï¼Œç„¶åå¯¹äºæŸä¸ªæœ€å¤§å€¼ï¼Œå¯ä»¥ä½œä¸ºæœ€å°å€¼çš„ä½ç½®æ˜¯ä¸€ä¸ªåŒºé—´ï¼Œæ‰¾å‡ºæ¥æ±‚å¹¶å†åé€‰å³å¯ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=2e5+9;
using ll=long long;

int p[N],c[N],d[N],n;
ll a[N],b[N],s[N],fp,fq;

inline void Solve(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	cin>>fp>>fq;

	iota(p+1,p+n+1,1);
	sort(p+1,p+n+1,[](int i,int j){return a[i]<a[j];});
	for(int i=1;i<=n;i++) s[i]=s[i-1]+(b[i]=a[p[i]]);
	for(int i=1;i<=n;i++){
		auto Check=[&](int p){return fp*(s[i]-s[p-1])>=b[i]*(i-p+1)*fq;};
		int l=0,r=i;
		while(l+1<r){
			int mid=l+r>>1;
			if(Check(mid)) r=mid;
			else l=mid;
		}
		c[i]=i-r+1;
	}
	
	int t=*max_element(c+1,c+n+1);
	for(int i=1,j=1;i<=n;i++){
		if(c[i]==t){
			auto Check=[&](int p){return fp*(s[i]-s[i-t+1]+b[p])>=b[i]*t*fq;};
			int l=0,r=i-t+1;
			while(l+1<r){
				int mid=l+r>>1;
				if(Check(mid)) r=mid;
				else l=mid;
			}
			d[r]++,d[i+1]--;
		}
	}

	vector<int> ans;
	for(int i=1;i<=n;i++) if(!(d[i]+=d[i-1])) ans.push_back(p[i]);
	sort(ans.begin(),ans.end());

	cout<<ans.size()<<endl;
	for(int x:ans) cout<<x<<' ';cout<<endl;

	for(int i=1;i<=n+1;i++) d[i]=0;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int T;
	cin>>T;
	while(T--) Solve();

	return 0;
}
```

### 8. Travel around China

ç”±äº $(*,l)\rightarrow (*,r)$ ä¸€å®šç»è¿‡ $l\leq p\leq r$ çš„ $p$ï¼Œè€ƒè™‘åˆ†æ²»ã€‚

ä»åˆ†æ²»ä¸­å¿ƒ $p$ å‡ºå‘ï¼Œè®¡ç®— $(o,p)$ åˆ° $[l,r]$ å†…æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯ $d_o(i,j)$ã€‚é‚£ä¹ˆ $\displaystyle \min_{o=1}^n dis_o(i_1,j_1)+dis_o(i_2,j_2)$ å³ä¸º $(i_1,j_1)$ åˆ° $(i_2,j_2)$ çš„æœ€çŸ­è·¯ã€‚è¿™ä¸ªä¸œè¥¿çš„å’Œæ˜¯ç»å…¸é—®é¢˜ï¼Œå¯ä»¥äºŒç»´ååºè§£å†³ã€‚

æœ€çŸ­è·¯éƒ¨åˆ†å¯ä»¥ç›´æ¥ DIjkstraï¼Œæ³¨æ„ $l$ å¤„å¯ä»¥ä» $(1,l)$ ç»•å‡ºå»å†ä» $(3,l)$ ç»•å›æ¥ï¼Œéœ€è¦ç‰¹åˆ¤ï¼Œ$r$ å¤„åŒç†ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n^2m\log^2 m)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int M=2e5+9;
const ll inf=1e18;
const int mod=1e9+7;

ll d[3][3][M],ans;
int a[3][M],vis[3][M],n,m;
const int dx[4]={-1,0,1,0};
const int dy[4]={0,-1,0,1};
inline void Dij(int si,int sj,int l,int r,ll ld,ll rd,ll dis[3][M]){
	for(int i:{0,1,2}) for(int j=l;j<=r;j++) dis[i][j]=inf,vis[i][j]=0;
	dis[si][sj]=a[si][sj];
	priority_queue<array<ll,3>> q;
	q.push({-dis[si][sj],si,sj});
	while(q.size()){
		int i=q.top()[1],j=q.top()[2];
		q.pop();
		if(vis[i][j]) continue ;
		vis[i][j]=1;
		if(j==l&&(~i&1)){
			int k=i^2;
			if(dis[i][j]+a[k][j]+ld<dis[k][j]){
				dis[k][j]=dis[i][j]+a[k][j]+ld;
				q.push({-dis[k][j],k,j});
			}
		}
		if(j==r&&(~i&1)){
			int k=i^2;
			if(dis[i][j]+a[k][j]+rd<dis[k][j]){
				dis[k][j]=dis[i][j]+a[k][j]+rd;
				q.push({-dis[k][j],k,j});
			}
		}
		for(int o:{0,1,2,3}){
			int ii=i+dx[o],jj=j+dy[o];
			if(ii<0||jj<l||ii>2||jj>r) continue ;
			if(dis[i][j]+a[ii][jj]<dis[ii][jj]){
				dis[ii][jj]=dis[i][j]+a[ii][jj];
				q.push({-dis[ii][jj],ii,jj});
			}
		}
	}
}

struct Fenw{
	int lim;
	ll tr[M<<2];
	inline void Add(int x,ll k){while(x<=lim) tr[x]+=k,x+=x&-x;}
	inline ll Ask(int x){ll sum=0;while(x) sum+=tr[x],x&=x-1;return sum;}
	inline ll Ask(int l,int r){return Ask(r)-Ask(l-1);}
	inline void Clear(){while(lim) tr[lim--]=0;}
}C,S;

inline void Conquer(int l,int r,ll ld,ll rd){
	if(l>r) return ;
	int mid=l+r>>1;
	for(int i:{0,1,2}){
		Dij(i,mid,l,r,ld,rd,d[i]);
		for(int j:{0,1,2}){
			for(int k=l;k<=r;k++){
				if(k!=mid||i<j) ans=(ans+d[i][j][k])%mod;
			}
		}
	}
	for(int i:{0,1,2}) for(int j:{0,1,2}) for(int k=r;k>mid;k--) d[i][j][k]-=a[i][mid];
	for(int i:{0,1,2}){
		int x=(i+1)%3,y=(i+2)%3;
		vector<ll> val;
		vector<array<ll,3>> lv,rv;
		for(int j:{0,1,2}){
			for(int k=l;k<mid;k++){
				lv.push_back({(d[i][j][k]-d[x][j][k])*3+i-x,(d[i][j][k]-d[y][j][k])*3+i-y,d[i][j][k]});
			}
			for(int k=r;k>mid;k--){
				rv.push_back({(d[x][j][k]-d[i][j][k])*3,(d[y][j][k]-d[i][j][k])*3,d[i][j][k]});
			}
		}
		val.push_back(-inf);
		for(auto &t:lv) val.push_back(t[1]);
		for(auto &t:rv) val.push_back(t[1]);
		sort(lv.begin(),lv.end());
		sort(rv.begin(),rv.end());
		sort(val.begin(),val.end());
		for(auto &t:lv) t[1]=lower_bound(val.begin(),val.end(),t[1])-val.begin();
		for(auto &t:rv) t[1]=lower_bound(val.begin(),val.end(),t[1])-val.begin();
		C.lim=S.lim=val.size()-1;
		for(int j=0,k=0;k<rv.size();k++){
			while(j<lv.size()&&lv[j][0]<=rv[k][0]){
				C.Add(lv[j][1],1);
				S.Add(lv[j][1],lv[j][2]);
				j++;
			}
			ans=(ans+C.Ask(rv[k][1])*rv[k][2])%mod;
			ans=(ans+S.Ask(rv[k][1]))%mod;
		}
		C.Clear();
		S.Clear();
	}
	ll md=d[0][2][mid];
	Conquer(l,mid-1,ld,md),Conquer(mid+1,r,md,rd);
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=0;i<n;i++){
		for(int j=1;j<=m;j++) cin>>a[i][j];
	}

	Conquer(1,m,inf,inf);
	ans=(ans<<1)%mod;

	cout<<ans<<endl;

	return 0;
}
```

### 10. Excluded Min

ä¸æ˜¯æˆ‘æ“äº†æ•°æ®ç»“æ„æ€ä¹ˆè¿™ä¹ˆéš¾å•Šã€‚

é¦–å…ˆç­”æ¡ˆæ˜¾ç„¶å¯ä»¥è½¬åŒ–æˆ $\displaystyle \max\{v|\sum_{x\in S} [x\lt v]\geq v\}$ï¼Œå…¶ä¸­å¯é‡é›† $S=a[l:r]$ã€‚

è€ƒè™‘ä»å¤§åˆ°å°æ‰«æ $v$ï¼Œé‚£ä¹ˆæœ‰äº› $a_i$ çš„æƒå€¼ä¼šä» $1$ å˜æˆ $0$ï¼Œå¯¹åº”åˆ°å¹³é¢ä¸Šç›¸å½“äºå¯¹ä¸€ä¸ª 2-side çŸ©å½¢å‡ $1$ï¼Œç»´æŠ¤æˆæœ¬å¾ˆé«˜ã€‚

å¦‚æœåªè€ƒè™‘ä¸€äº›ä¸ç›¸äº¤çš„çº¿æ®µï¼Œé‚£ä¹ˆç›¸å½“äºå¯¹ä¸€ä¸ªæ’åºåçš„è¯¢é—®åŒºé—´å‡ $1$ï¼Œè€Œè¿™é¢˜æœ‰æ€§è´¨è¢«åŒ…å«çš„åŒºé—´çš„ç­”æ¡ˆä¸€å®šæ¯”åŒ…å«çš„åŒºé—´çš„å°ã€‚é‚£ä¹ˆå½“ä¸€ä¸ªçº¿æ®µæ±‚å¾—ç­”æ¡ˆä¹‹åæŠŠå®ƒåˆ é™¤å†æ·»åŠ æ–°çš„å…¥åº¦ä¸º $0$ çš„çº¿æ®µå³å¯åšåˆ°æ—¶åˆ»çº¿æ®µä¸ç›¸äº’åŒ…å«ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=5e5+9;
const int inf=1e9+7;

vector<int> b[N];
int a[N],ql[N],qr[N],ans[N],p[N],ip[N],n,q;

multiset<array<int,2>> ls,rs;
namespace Fenw{
	int tr[N];
	inline void Add(int x,int k){while(x<=n) tr[x]+=k,x+=x&-x;}
	inline int Ask(int x){int sum=0;while(x) sum+=tr[x],x&=x-1;return sum;}
	inline int Ask(int l,int r){return Ask(r)-Ask(l-1);}
}
namespace SgT{
	struct Node{
		int tag;
		array<int,2> dat;
	}tr[N<<2];
	inline void PushUp(int x){tr[x].dat=max(tr[x<<1].dat,tr[x<<1|1].dat);}
	inline void Push(int x,int k){tr[x].dat[0]+=k,tr[x].tag+=k;}
	inline void PushDown(int x){
		if(tr[x].tag){
			Push(x<<1,tr[x].tag);
			Push(x<<1|1,tr[x].tag);
			tr[x].tag=0;
		}
	}
	inline void Build(int x,int L,int R){
		if(L==R) return tr[x].dat={-inf,L},void();
		int mid=L+R>>1;
		Build(x<<1,L,mid),Build(x<<1|1,mid+1,R);
		PushUp(x);
	}
	inline void Modify(int x,int L,int R,int l,int r,int k){
		if(l>r) return ;
		if(l<=L&&R<=r) return Push(x,k);
		PushDown(x);
		int mid=L+R>>1;
		if(l<=mid) Modify(x<<1,L,mid,l,r,k);
		if(r>mid) Modify(x<<1|1,mid+1,R,l,r,k);
		PushUp(x);
	}
	inline void Set(int x,int L,int R,int pos,array<int,2> k){
		if(L==R) return tr[x].dat=k,void();
		PushDown(x);
		int mid=L+R>>1;
		if(pos<=mid) Set(x<<1,L,mid,pos,k);
		else Set(x<<1|1,mid+1,R,pos,k);
		PushUp(x);
	}
}
namespace TgS{
	struct Data{
		int a,b,p;
		Data(){}
		Data(int _a,int _b,int _p){a=_a,b=_b,p=_p;}
		inline friend Data operator +(Data x,Data y){
			if(y.b<=x.a) y.b=-inf,y.p=-inf;
			if(x.b>y.b) return Data(max(x.a,y.a),x.b,x.p);
			else return Data(max(x.a,y.a),y.b,y.p);
		}
	};
	struct Node{
		Data dat=Data(-inf,-inf,-inf);
	}tr[N<<2];
	inline void PushUp(int x){tr[x].dat=tr[x<<1].dat+tr[x<<1|1].dat;}
	inline void Set(int x,int L,int R,int pos,Data k){
		if(L==R) return tr[x].dat=k,void();
		int mid=L+R>>1;
		if(pos<=mid) Set(x<<1,L,mid,pos,k);
		else Set(x<<1|1,mid+1,R,pos,k);
		PushUp(x);
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i],a[i]=min(a[i],n);
	for(int i=1;i<=q;i++) cin>>ql[i]>>qr[i];

	iota(p+1,p+q+1,1);
	sort(p+1,p+q+1,[](int i,int j){
		return ql[i]^ql[j]?ql[i]<ql[j]:qr[i]>qr[j];
	});
	for(int i=1;i<=q;i++) ip[p[i]]=i;
	for(int i=1;i<=n;i++) b[a[i]].push_back(i);

	SgT::Build(1,1,q);
	ls.insert({-inf,0});
	rs.insert({inf,q+1});
	for(int i=1;i<=n;i++) Fenw::Add(i,1);
	for(int i=1,j=0;i<=q;i++){
		if(qr[p[i]]<=qr[p[j]]) TgS::Set(1,1,q,i,TgS::Data(-inf,qr[p[i]],i));
		else{
			ls.insert({ql[p[i]],i});
			rs.insert({qr[p[i]],i});
			TgS::Set(1,1,q,i,TgS::Data(qr[p[i]],-inf,-inf));
			SgT::Set(1,1,q,i,{Fenw::Ask(ql[p[i]],qr[p[i]]),i});
			j=i;
		}
	}

	for(int v=n;~v;v--){
		for(int i:b[v]){
			Fenw::Add(i,-1);
			int lp=(*rs.lower_bound({i,0}))[1];
			int rp=(*--ls.lower_bound({i+1,0}))[1];
			SgT::Modify(1,1,q,lp,rp,-1);
		}
		while(SgT::tr[1].dat[0]>=v){
			int i=SgT::tr[1].dat[1];
			ans[p[i]]=v;
			ls.erase({ql[p[i]],i});
			rs.erase({qr[p[i]],i});
			SgT::Set(1,1,q,i,{-inf,i});
			TgS::Set(1,1,q,i,TgS::Data(-inf,-inf,-inf));
			while(true){
				int j=TgS::tr[1].dat.p;
				if(j==-inf) break ;
				TgS::Set(1,1,q,j,TgS::Data(qr[p[j]],-inf,-inf));
				ls.insert({ql[p[j]],j});
				rs.insert({qr[p[j]],j});
				SgT::Set(1,1,q,j,{Fenw::Ask(ql[p[j]],qr[p[j]]),j});
			}
		}
	}

	for(int i=1;i<=q;i++) cout<<ans[i]<<endl;

	return 0;
}
```

### 11./114. Best Subsequence

#### Easy Version (a.k.a. 114. ~)

å…ˆäºŒåˆ†ç­”æ¡ˆ $w$ï¼Œå°†æ•°æŒ‰æ˜¯å¦å¤§äº $\lfloor\dfrac w2\rfloor$ åˆ†ä¸ºå¤§æ•°å’Œå°æ•°ã€‚

é‚£ä¹ˆå°æ•°è‚¯å®šé€‰ï¼Œä¸¤ä¸ªå°æ•°ä¹‹é—´å°±å°è¯•é€‰æœ€å°çš„å¤§æ•°ï¼Œå¦‚æœåˆæ³•å°±åŠ å…¥ç­”æ¡ˆï¼Œè¿™æ ·å°±æ˜¯ $O(n\log V)$ çš„ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=5e5+9;

int a[N],n,k;

inline int Count(int w){
	int cnt=0;
	for(int i=1;i<=n;i++) if(a[i]<=(w>>1)) cnt++;
	if(!cnt) return 0;
	int lp=n,rp=0;
	for(int i=1;i<=n;i++){
		if(a[i]>(w>>1)) continue ;
		if(!rp) lp=rp=i;
		else{
			if(rp+1<i){
				int k=*min_element(a+rp+1,a+i);
				if(ll(max(a[i],a[rp]))+k<=w) cnt++;
			}
			rp=i;
		}
	}
	int k=2e9;
	if(lp!=1) k=min(k,*min_element(a+1,a+lp));
	if(rp!=n) k=min(k,*min_element(a+rp+1,a+n+1));
	if(ll(max(a[lp],a[rp]))+k<=w) cnt++;
	return cnt;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];

	int L=-1,R=2e9+1;
	while(L+1<R){
		int mid=ll(L)+R>>1;
		if(Count(mid)>=k) R=mid;
		else L=mid;
	}

	cout<<R<<endl;

	return 0;
}
```

#### Hard Version (a.k.a. 11. ~)

è€ƒè™‘æœ‰å¤šæ¬¡è¯¢é—®æ€ä¹ˆåšã€‚

å°è¯•æ‰¾å‡ºæ‰€æœ‰å°æ•°-å¤§æ•°-å°æ•°æœ‰æ•ˆç»„åˆ $(i,j,k)$ï¼Œè¿™ä¼šå¯¹ $w\in[\max(a_i,a_k)+a_j,2a_j)$ äº§ç”Ÿ $1$ çš„è´¡çŒ®ã€‚ç”±äº $(i,k)$ ä¸­ä¸å­˜åœ¨ $a_p<a_j$ çš„ $p$ï¼Œå› æ­¤ $a_i,a_k$ åˆ†åˆ«ä¸º $j$ å·¦å³ç¬¬ä¸€ä¸ªæ¯” $a_j$ å°çš„æ•°ï¼Œå•è°ƒæ ˆæ‰¾å‡ºå³å¯ã€‚

è€ƒè™‘å¯¹å€¼åŸŸå»ºå‡ºå¯æŒä¹…åŒ–çº¿æ®µæ ‘ï¼Œå°æ•°çš„è´¡çŒ®æ˜¯å®¹æ˜“ç»´æŠ¤çš„ã€‚$(i,j,k)$ å¯¹çš„è€ƒè™‘å…¨éƒ¨è®°åœ¨ $k$ çš„ä½ç½®ï¼Œå¯¹äºè¯¢é—® $[l,r]$ï¼Œåˆ†åˆ«æ‰¾å‡ºå…¶æœ€å·¦æœ€å³çš„å°æ•° $a_L,a_R$ï¼Œé‚£ä¹ˆç”±äº $a_L$ æ˜¯å°æ•°ï¼Œé‚£ä¹ˆ $k\in(L,R]$ çš„ $(i,j,k)$ å¿…ç„¶æ»¡è¶³ $l\leq L\leq i,j,k\leq R\leq r$ã€‚å‰©ä¸‹æ–­ç¯ä¸ºé“¾ä¸¢å¤±çš„è´¡çŒ®æœ€åè¡¥ä¸Šå³å¯ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log V+q\log^2 V)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=1e5+9;
const int lgN=2e1;
const int inf=2e9;

int a[N],mn[lgN][N],n,q;
inline void InitRMQ(){
	for(int i=1;i<=n;i++) mn[0][i]=a[i];
	for(int k=1;k<=__lg(n);k++){
		for(int i=1;i+(1<<k)-1<=n;i++){
			mn[k][i]=min(mn[k-1][i],mn[k-1][i+(1<<k-1)]);
		}
	}
}
inline int Min(int l,int r){
	if(l>r) return inf;
	int k=__lg(r-l+1);
	return min(mn[k][l],mn[k][r-(1<<k)+1]);
}

struct Node{
	int lc,rc,dat;
}tr[N<<7];

int root[N],cnt;
inline int Allc(){return ++cnt;}
inline int Clone(int x){int y=Allc();tr[y]=tr[x];return y;}
inline void PushUp(int x){tr[x].dat=tr[tr[x].lc].dat+tr[tr[x].rc].dat;}
inline void Modify(int &x,int L,int R,int pos,int k){
	x=Clone(x);
	if(L==R) return tr[x].dat+=k,void();
	int mid=ll(L)+R>>1;
	if(pos<=mid) Modify(tr[x].lc,L,mid,pos,k);
	else Modify(tr[x].rc,mid+1,R,pos,k);
	PushUp(x);
}
inline int Query(int x,int L,int R,int l,int r){
	if(!x) return 0;
	if(l<=L&&R<=r) return tr[x].dat;
	int mid=ll(L)+R>>1,ans=0;
	if(l<=mid) ans+=Query(tr[x].lc,L,mid,l,r);
	if(r>mid) ans+=Query(tr[x].rc,mid+1,R,l,r);
	return ans;
}

inline int LApr(int p,int k){
	int l=p-1,r=n+1;
	while(l+1<r){
		int mid=l+r>>1;
		if(Min(p,mid)<=k) r=mid;
		else l=mid;
	}
	return r;
}
inline int RApr(int p,int k){
	int l=0,r=p+1;
	while(l+1<r){
		int mid=l+r>>1;
		if(Min(mid,p)<=k) l=mid;
		else r=mid;
	}
	return l;
}
inline int Count(int l,int r,int w){
	int lp=LApr(l,w>>1),rp=RApr(r,w>>1),ans=0;
	if(lp>r||rp<l) return ans;
	ans+=Query(root[rp],0,inf,0,w)-Query(root[lp],0,inf,0,w)+1;
	ans+=(ll(min(Min(l,lp-1),Min(rp+1,r)))+max(a[lp],a[rp])<=w);
	return ans;
}
inline int Calc(int l,int r,int k){
	int L=-1,R=inf+1;
	while(L+1<R){
		int mid=ll(L)+R>>1;
		if(Count(l,r,mid)>=k) R=mid;
		else L=mid;
	}
	return R;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i];

	InitRMQ();
	vector<int> stk;
	for(int i=1;i<=n;i++){
		Modify(root[i]=root[i-1],0,inf,a[i]<<1,1);
		while(stk.size()&&a[stk.back()]>=a[i]){
			if(stk.size()>1){
				int j=stk.end()[-1],k=stk.end()[-2];
				Modify(root[i],0,inf,a[j]+max(a[i],a[k]),1);
				Modify(root[i],0,inf,a[j]<<1,-1);
			}
			stk.pop_back();
		}
		stk.push_back(i);
	}

	while(q--){
		int l,r,k;
		cin>>l>>r>>k;
		cout<<Calc(l,r,k)<<endl;
	}
	
	return 0;
}
```

### 12. Binary Search Tree

é¦–å…ˆæŠŠæ•°æ‰”åˆ°å€¼åŸŸä¸Šçœ‹å°±æ˜¯ä»¥æ’å…¥æ—¶é—´ä¸º prio çš„ç¬›å¡å°”æ ‘ã€‚

è€Œç¬›å¡å°”æ ‘ä¸Šçš„å·¦çˆ¶äº²å’Œå³çˆ¶äº²åˆ†åˆ«å°±æ˜¯å‰ç¼€/åç¼€æœ€å°å€¼ã€‚

é‚£ä¹ˆç¦»çº¿ä¸‹æ¥ç›´æ¥æ¥¼æˆ¿é‡å»ºç»´æŠ¤å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n\log^2 n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=2e5+9;
const int inf=1e9+7;

ll ans[N];
int op[N],w[N],t[N],n,q,tot;
vector<array<int,2>> opr[N];
vector<int> qry[N],val;

struct SgT{
	struct Node{
		int l,r;
		ll mn,sum;
	}tr[N<<2];

	inline ll Calc(int x,int k){
		if(k<=tr[x].mn) return 0;
		if(tr[x].l==tr[x].r) return w[tr[x].mn];
		if(k<=tr[x<<1|1].mn) return Calc(x<<1,k);
		else return Calc(x<<1|1,k)+tr[x].sum-tr[x<<1|1].sum;
	}
	inline void PushUp(int x){
		tr[x].mn=min(tr[x<<1].mn,tr[x<<1|1].mn);
		tr[x].sum=tr[x<<1|1].sum+Calc(x<<1,tr[x<<1|1].mn);
	}
	inline void Build(int x,int l,int r){
		tr[x].l=l,tr[x].r=r;
		if(tr[x].l==tr[x].r) return tr[x].mn=q+1,void();
		int mid=tr[x].l+tr[x].r>>1;
		Build(x<<1,l,mid),Build(x<<1|1,mid+1,r);
		PushUp(x);
	}
	inline void Set(int x,int pos,int k){
		if(tr[x].l==tr[x].r) return tr[x].mn=k,tr[x].sum=w[k],void();
		int mid=tr[x].l+tr[x].r>>1;
		if(pos<=mid) Set(x<<1,pos,k);
		else Set(x<<1|1,pos,k);
		PushUp(x);
	}
	inline array<ll,2> Prefix(int x,int pos,ll k){
		if(pos<tr[x].l) return {0,q+1};
		if(tr[x].l==tr[x].r) return {Calc(x,k),min(k,tr[x].mn)};
		int mid=tr[x].l+tr[x].r>>1;
		if(pos<=mid) return Prefix(x<<1,pos,k);
		else{
			auto res=Prefix(x<<1|1,pos,k);
			return {res[0]+Calc(x<<1,res[1]),min(res[1],tr[x<<1].mn)};
		}
	}
}T,R;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>q;
	for(int i=1,l,r,x;i<=q;i++){
		cin>>op[i];
		if(op[i]==1){
			cin>>l>>r>>w[i];
			opr[l].push_back({w[i],i});
			opr[r+1].push_back({w[i],q+1});
		}else{
			cin>>x>>w[i];
			qry[x].push_back(i);
		}
		val.push_back(w[i]);
	}

	val.push_back(0);
	sort(val.begin(),val.end());
	val.erase(unique(val.begin(),val.end()),val.end());
	tot=val.size()-1;
	
	w[q+1]=inf;
	T.Build(1,1,tot);
	R.Build(1,1,tot);
	for(int i=1;i<=tot;i++) t[i]=q+1;
	for(int i=1;i<=n;i++){
		for(auto p:opr[i]){
			p[0]=lower_bound(val.begin(),val.end(),p[0])-val.begin();
			T.Set(1,p[0],p[1]);
			R.Set(1,tot-p[0]+1,p[1]);
			t[p[0]]=p[1]+1;
		}
		for(int j:qry[i]){
			int p=lower_bound(val.begin(),val.end(),w[j])-val.begin();
			ans[j]=T.Prefix(1,p,min(j,t[p]))[0]+R.Prefix(1,tot-p,min(j,t[p]))[0];
		}
	}

	for(int i=1;i<=q;i++) if(op[i]==2) cout<<ans[i]<<endl;

	return 0;
}
```

### 27. AND Permutation

è¦æ·±åˆ»åæ€äº†ã€‚

è€ƒè™‘ä»ä½åˆ°é«˜å½’çº³æ„é€ ï¼Œå…ˆå°†åŸé›†åˆ $S$ æŒ‰å½“å‰ä½åˆ†æˆ $S_0$ å’Œ $S_1$ å¹¶æ¶ˆå»å½“å‰ä½ï¼Œé€’å½’ä¸‹å»æ„é€ ã€‚è¿˜åŸ $S_1$ æ—¶ä¼šå‡ºç°å½“å‰ä½å‡ä¸º $1$ è€Œé€ æˆæœ‰äº¤çš„æƒ…å†µï¼Œè€ƒè™‘åˆ° $S_1$ åœ¨ $S_0$ ä¸­ä¸€å®šæœ‰ä¸€ä¸ªå¯¹åº”çš„å€¼ï¼Œè¿˜åŸåäº¤æ¢åŒ¹é…å¯¹è±¡å³å¯ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ï¼Œæ¯”è¾ƒæ‡’å†™äº† mapï¼Œæ—¶é—´å¤æ‚åº¦ $O(n\log^2 n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=(1<<18)+9;

int n;
ll a[N];
map<ll,ll> b;
inline void Construct(vector<ll> v,int d){
	if(d<0||!v.size()) return ;
	vector<ll> s[2];
	for(ll x:v) s[x>>d&1].push_back(x);
	Construct(s[0],d-1);
	Construct(s[1],d-1);
	for(ll x:s[1]){
		swap(b[x],b[x^(1ll<<d)]);
		b[x^(1ll<<d)]|=1ll<<d;
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],b[a[i]]=0;

	Construct(vector<ll>(a+1,a+n+1),60);

	for(int i=1;i<=n;i++) cout<<b[a[i]]<<endl;

	return 0;
}
```

### 36. Nein

é¦–å…ˆç›´æ¥è®¡ç®—ç­”æ¡ˆçœ‹èµ·æ¥ä¸æ˜¯å¾ˆå¥½åšï¼Œè€ƒè™‘æ±‚è§£ç¬¬ $n$ å¤§çš„ä¸åŒ…å« $9$ çš„ $10^k-1$ çš„å€æ•°ã€‚

ç”±äº $10^k-1$ æœ‰å¾ªç¯æº¢å‡ºçš„æ€§è´¨ï¼Œæ‰€ä»¥ $10^k-1$ çš„å€æ•°æŒ‰æ¯ $k$ ä¸ªæ•°åˆ†ä¸€æ®µåŠ èµ·æ¥çš„å’Œä¸€å®šä¹Ÿæ˜¯ $10^k-1$ çš„å€æ•°ï¼Œè€Œä¸”å‡è®¾å…±æœ‰ $B$ æ®µï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°ä½å’Œä¸€å®šä¸ä¼šå¤§äº $B(10^k-1)$ã€‚

è€ƒè™‘ä»é«˜åˆ°ä½ä¾æ¬¡ç¡®å®šç­”æ¡ˆæ¯ä¸€ä½ï¼Œé‚£ä¹ˆéœ€è¦è®¡ç®—ç¡®å®šä¸€ä¸ªå‰ç¼€ä¹‹åçš„åˆæ³•æ–¹æ¡ˆæ•°ã€‚ä»¤å‰é¢å·²ç»å¡«å‡ºæ¥çš„æ•°ä½å’Œæ˜¯ $-r\pmod{10^k-1}$ï¼Œåˆ™åé¢å¡«å‡ºæ¥çš„æ•°ä½å’Œå°±æ˜¯ $r+t(10^k-1)$ï¼Œå…¶ä¸­ $t\in[0,B]$ã€‚å› ä¸º $t$ å¾ˆå°ï¼Œæ‰€ä»¥ç›´æ¥æšä¸¾ $r+t(10^k-1)$ æ˜¯ä»€ä¹ˆï¼Œç„¶åå°±å¯ä»¥ç›´æ¥æ•°ä½ DPã€‚å…·ä½“åœ°ï¼Œè®¾ $g_{i,j}$ è¡¨ç¤ºç›®å‰å¡«åˆ°æ•°ä½å’Œçš„ç¬¬ $i$ ä½ï¼Œå¹¶ä»ä¸‹é¢æ¥å—äº† $j$ æ¬¡è¿›ä½çš„æ–¹æ¡ˆæ•°ã€‚é‚£ä¹ˆæœ‰è½¬ç§» $\displaystyle g_{i,j}=\sum_{k=0}^B g_{i-1,k}f_{c_{i-1},10j+s_{i-1}-k}$ï¼Œå…¶ä¸­ $\displaystyle f_{i,j}=(\sum_{t=0}^8x^t)^i[x^j]$ï¼Œ$c_i$ è¡¨ç¤ºåç¼€ä¸­ä¸‹æ ‡æ¨¡ $k$ ä¸ $i$ åŒä½™çš„ä½çš„ä¸ªæ•°ï¼Œ$s_i$ åˆ™æ˜¯ $r+t(10^k-1)$ çš„ç¬¬ $i$ ä½ï¼Œæ–¹æ¡ˆæ•°å³ä¸º $\displaystyle g_{k,\lfloor \frac {r+t(10^k-1)}{10^k}\rfloor}$ã€‚

æ—¶é—´å¤æ‚åº¦ $O(9kT^4)$ï¼Œå…¶ä¸­ $T=37$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

using ll=long long;
using bint=__int128;

const int D=4e2;
const bint T=1e18;

ll k,n;
bint f[D][D<<3],g[D][D],p10[D];
inline bint Count(int t,bint lft,vector<int> &cnt){
	if(!t) return !lft;
	vector<int> trg(k+1);
	for(int i=0;i<k;i++) trg[i]=lft%10,lft/=10;
	g[0][0]=1;
	for(int i=0;i<k;i++){
		for(int p=0;p<=t;p++){
			for(int q=0;q<=t;q++){
				if(p*10+trg[i]-q>=0) g[i+1][p]+=g[i][q]*f[cnt[i]][p*10+trg[i]-q];	
			}
		}
	}
	bint ans=g[k][lft];
	for(int i=0;i<=k;i++){
		for(int p=0;p<=t;p++) g[i][p]=0;
	}
	return ans;
}

signed main(){
	cin>>k>>n;

	f[0][0]=1,p10[0]=1;
	for(int i=1;i<=37;i++){
		for(int j=0;j<=i*8;j++){
			for(int k=j;k>=max(j-8,0);k--) f[i][j]+=f[i-1][k];
		}
	}
	for(int i=1;i<=37;i++) p10[i]=p10[i-1]*10;

	bint ans=0,s9=0;
	for(int i=0;i<k;i++) s9=s9*10+9;
	for(int i=37;~i;i--){
		int t=(i+k-1)/k;
		vector<int> cnt(k,0);
		for(int j=0;j<i;j++) cnt[j%k]++;
		for(int x=0;x<9;x++){
			bint sum=-!ans;
			for(int c=0;c<=t;c++){
				bint lft=c*s9+(s9-ans%s9)%s9;
				sum+=Count(t,lft,cnt);
			}
			if(n<=sum) break ;
			n-=sum,ans+=p10[i];
		}
	}

	ans/=s9;

	if(ans<T) cout<<ll(ans)<<endl;
	else cout<<ll(ans/T)<<setw(18)<<setfill('0')<<ll(ans%T)<<endl;

	return 0;
}
```

### 41. Link Cut Digraph

ç»å…¸æ°¸æµä¼ ã€‚

è€ƒè™‘æ•´ä½“äºŒåˆ†ç¬¬ $i$ æ¡è¾¹èƒ½å¤ŸåŠ å…¥åˆ°æŸä¸ª SCC çš„æ—¶é—´ $t_i$ï¼ŒåŸå…ˆå…¨éƒ¨æš‚å®š $t_i=i$ã€‚é‚£ä¹ˆäºŒåˆ† $[l,r]$ çš„æ—¶å€™ï¼Œ$t_i\in(r,+\infty]$ çš„è¾¹è‚¯å®šä¸ä¼šèµ·åˆ°ä»»ä½•ä½œç”¨ï¼Œè€Œ $[1,l)$ çš„è¾¹åˆ™å·²ç»è¢«ç¼©å®Œäº†ï¼Œäºæ˜¯å¯ä»¥è¢«è¡¨è¾¾æˆ SCC å†…éƒ¨çš„è¾¹ï¼Œå³ç¼©å®Œç‚¹ä¹‹åå…¨éƒ¨åœ¨ SCC å†…éƒ¨ï¼Œä¹Ÿä¸ä¼šèµ·åˆ°ä½œç”¨ã€‚å› æ­¤äºŒåˆ†æ—¶ä»…éœ€åŠ å…¥ $t_i\in[l,mid]$ çš„è¾¹ï¼Œè‹¥æŸæ¡è¾¹æ²¡èƒ½æˆåŠŸåŠ å…¥ä¸€ä¸ª SCCï¼Œåˆ™ $t_i\leftarrow mid+1$ã€‚ç»§ç»­æ•´ä½“äºŒåˆ†å³å¯ã€‚åœ¨è·‘å³è¾¹ä¹‹å‰éœ€è¦æŠŠåŒå±ä¸€ä¸ª SCC çš„ç‚¹ç¼©åœ¨ä¸€èµ·ï¼Œé¡ºå¸¦ç»´æŠ¤ä¸€ä¸‹ SCC å¤§å°ã€‚

æ—¶é—´å¤æ‚åº¦ $O(m\log m)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=3e5+9;

ll ans[N];
int ep[N],eq[N],t[N],n,m;

ll cur;
int fa[N],siz[N];
inline int Find(int x){return x==fa[x]?x:fa[x]=Find(fa[x]);}
inline void Merge(int x,int y){
	x=Find(x),y=Find(y);
	if(x==y) return ;
	if(siz[x]<siz[y]) swap(x,y);
	cur-=1ll*siz[x]*(siz[x]-1)/2;
	cur-=1ll*siz[y]*(siz[y]-1)/2;
	fa[y]=x;
	siz[x]+=siz[y];
	cur+=1ll*siz[x]*(siz[x]-1)/2;
}

vector<int> e[N],stk;
int dfn[N],low[N],ins[N],bel[N],dcnt;
inline void Tarjan(int x){
	ins[x]=1,stk.push_back(x);
	dfn[x]=low[x]=++dcnt;
	for(int y:e[x]){
		if(!dfn[y]){
			Tarjan(y);
			low[x]=min(low[x],low[y]);
		}else if(ins[y]) low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		while(stk.size()){
			int p=stk.back();
			stk.pop_back();
			ins[p]=0;
			bel[p]=x;
			if(p==x) break ;
		}
	}
}
inline void BinSch(int l,int r,vector<int> &v){
	int mid=l+r>>1;
	vector<int> node;
	for(int i:v){
		if(t[i]>mid) continue ;
		e[Find(ep[i])].push_back(Find(eq[i]));
		node.push_back(Find(ep[i]));
		node.push_back(Find(eq[i]));
	}

	for(int x:node) if(!dfn[x]) Tarjan(x);
	auto Clear=[&](){
		for(int x:node){
			dfn[x]=low[x]=ins[x]=bel[x]=0;
			e[x].clear();
		}
		dcnt=0;
	};

	if(l==r){
		for(int x:node) Merge(x,bel[x]);
		ans[l]=cur;
		Clear();
	}else{
		vector<int> lv,rv;
		for(int i:v){
			if(t[i]>mid) rv.push_back(i);
			else{
				if(bel[Find(ep[i])]==bel[Find(eq[i])]) lv.push_back(i);
				else t[i]=mid+1,rv.push_back(i);
			}
		}
		Clear();
		BinSch(l,mid,lv);
		BinSch(mid+1,r,rv);
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=1;i<=m;i++) cin>>ep[i]>>eq[i];

	for(int i=1;i<=n;i++) fa[i]=i,siz[i]=1;
	for(int i=1;i<=m;i++) t[i]=i;
	vector<int> v(m);
	iota(v.begin(),v.end(),1);

	BinSch(1,m,v);

	for(int i=1;i<=m;i++) cout<<ans[i]<<endl;

	return 0;
}
```

### 44. AND PLUS OR

ä¸æ˜¯æˆ‘è·Ÿä½ ä»¬è¿™ç¾¤é«˜æ™ºå•†äººç¾¤æ‹¼äº†ã€‚

è€ƒè™‘æŠŠç­”æ¡ˆçš„ $S$ å’Œ $T$ è°ƒæ•´æˆæ¯”è¾ƒå¥½çœ‹çš„å½¢å¼ã€‚

> **ç»“è®º**ï¼šå¦‚æœ $A$ æœ‰è§£ï¼Œé‚£ä¹ˆä¸€å®šå­˜åœ¨ä¸€ç»„ $S,T$ ä½¿å¾— $(S,T)$ æ˜¯åˆæ³•ç­”æ¡ˆä¸” $|S\oplus T|=2$ã€‚
>
> **è¯æ˜**ï¼š
>
> æ˜¾ç„¶ $|S\oplus T|\lt 2$ è‚¯å®šä¸åˆæ³•ã€‚
>
> è®¾ $(S_0,T_0)$ ä¸º $A$ çš„ä¸€ç»„ $|S_0\oplus T_0|$ æœ€å°çš„è§£ï¼Œå¹¶å‡è®¾ $|S\setminus T|<|T\setminus S|\neq 1$ã€‚
>
> ä»¤ $P=S\cap T,Q=S\setminus T,R=T\setminus S,x\in R,R'=R/\{x\}$ã€‚
>
> é‚£ä¹ˆ $(P\cup Q\cup R',P \cup R' \cup \{x\})$ å’Œ $(P\cup Q,P \cup R')$ ä¸åˆæ³•ï¼Œä½† $(P\cup Q,P\cup R'\cup \{x\})$ åˆæ³•ï¼Œå³ï¼š
>
> - $A(P\cup Q)+A(P\cup R'\cup \{x\}) \lt A(P)+A(P\cup Q\cup R'\cup \{x\})$ã€‚
> - $A(P\cup Q\cup R')+A(P \cup R' \cup \{x\}) \geq A(P\cup R')+A(P\cup Q\cup R'\cup \{x\})$ã€‚
> - $A(P\cup Q)+A(P \cup R')\geq A(P)+A(P\cup Q\cup R')$ã€‚
>
> å®¹æ˜“å‘ç°äºŒå¼åŠ ä¸‰å¼ä¸ä¸€å¼çŸ›ç›¾ã€‚
>
> å› æ­¤å¯ä»¥è¯´æ˜ $(P\cup Q\cup R',P \cup R' \cup \{x\})$ å’Œ $(P\cup Q,P \cup R')$ è‡³å°‘æœ‰ä¸€ç»„åˆæ³•ï¼Œä»è€Œå¯ä»¥ä¸æ–­æŠŠ $|T\setminus S|$ è°ƒæ•´åˆ° $1$ã€‚
>
> å¯¹ $|S\setminus T|$ åšåŒæ ·çš„æ“ä½œå³å¯ä»¤ $|S\oplus T|=|S\setminus T|+|T\setminus S|=2$ã€‚

$|S\oplus T|=2$ çš„ $(S,T)$ åªæœ‰ $O(n^22^n)$ å¯¹ï¼Œæšä¸¾æ‰¾å‡ºç­”æ¡ˆå³å¯ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=(1<<20)+9;

int a[N],n;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=0;i<(1<<n);i++) cin>>a[i];

	for(int sta=0;sta<(1<<n);sta++){
		for(int i=0;i<n;i++){
			for(int j=i+1;j<n;j++){
				int tta=sta^(1<<i)^(1<<j);
				if(a[sta]+a[tta]<a[sta&tta]+a[sta|tta]){
					cout<<sta<<' '<<tta<<endl;
					return 0;
				}
			}
		}
	}

	cout<<-1<<endl;

	return 0;
}
```

### 53. Good Coloring

ç»™æ¯æ¡è¾¹æŒ‰é¢œè‰²å¤§å°ä»å°åˆ°å¤§å®šå‘ï¼Œè·‘æœ€é•¿è·¯ï¼ŒæŒ‰æœ€é•¿è·¯æŸ“è‰²å³å¯ã€‚

è¯æ˜æ˜¾ç„¶ï¼Œæœ€é•¿è·¯æ˜¾ç„¶ä¸ä¼šå¤§äº $k$ï¼Œå¦‚æœä¸¤ä¸ªç›¸é‚»çš„ç‚¹ç›¸åŒæ˜¾ç„¶ä¸æ˜¯æœ€é•¿è·¯ã€‚

ç”±äºæ˜¯ DAG å¯ä»¥ç›´æ¥æ‹“æ‰‘æ’åºï¼Œæ—¶é—´å¤æ‚åº¦ $O(n+m)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=6e5+9;

int c[N],n,m,k;
vector<int> e[N];

int dis[N],pre[N],in[N];
inline void LPFA(){
	queue<int> q;
	for(int i=1;i<=n;i++){
		dis[i]=pre[i]=0;
		if(!in[i]) q.push(i);
	}
	while(q.size()){
		int x=q.front();
		q.pop();
		for(int y:e[x]){
			if(dis[x]+1>dis[y]){
				pre[y]=x;
				dis[y]=dis[x]+1;
			}
			if(!--in[y]) q.push(y);
		}
	}
}
inline void Solve(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		if(c[u]>c[v]) e[u].push_back(v),in[v]++;
		else e[v].push_back(u),in[u]++;
	}

	LPFA();

	int p=max_element(dis+1,dis+n+1)-dis;
	cout<<dis[p]+1<<' ';
	for(int i=1;i<=n;i++) cout<<dis[i]+1<<' ';cout<<endl;
	while(p) cout<<p<<' ',p=pre[p];cout<<endl;

	for(int i=1;i<=n;i++) e[i].clear();
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);
	
	int T;
	cin>>T;
	while(T--) Solve();
	
	return 0;
}
```

### 65. Building Bombing

$L$ ä¹‹å‰çš„ç‚¹æ²¡å•¥ç”¨ï¼Œå¯¹äº $L$ åé¢çš„ç‚¹è®¾ $f_{i,j}$ è¡¨ç¤ºä½¿ $i$ æˆä¸º $L$ åé¢ç¬¬ $j$ å°çš„è¦æ“ä½œå‡ æ¬¡ï¼Œæœ‰è½¬ç§»ï¼š

-   $\displaystyle f_{i,j}=\min_{L\leq p<i} (f_{p,j-1}+\sum_{q=p+1}^i[h_q>h_p])$ã€‚

è¿™æ˜¾ç„¶æ˜¯æ–¹ä¾¿ç”¨åŒºé—´åŠ åŒºé—´æœ€å°å€¼å€¼åŸŸçº¿æ®µæ ‘ç»´æŠ¤çš„ï¼Œæ—¶é—´å¤æ‚åº¦ $O(nk\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=1e5+9;
const int inf=1e9+7;

struct Node{
	int l,r,dat,tag;
}tr[N<<2];

inline void PushUp(int x){tr[x].dat=min(tr[x<<1].dat,tr[x<<1|1].dat);}
inline void Push(int x,int k){tr[x].dat+=k,tr[x].tag+=k;}
inline void PushDown(int x){
	if(tr[x].tag){
		Push(x<<1,tr[x].tag);
		Push(x<<1|1,tr[x].tag);
		tr[x].tag=0;
	}
}
inline void Build(int x,int l,int r){
	tr[x].l=l,tr[x].r=r,tr[x].tag=0;
	if(tr[x].l==tr[x].r) return tr[x].dat=inf,void();
	int mid=tr[x].l+tr[x].r>>1;
	Build(x<<1,l,mid),Build(x<<1|1,mid+1,r);
	PushUp(x);
}
inline void Set(int x,int pos,int k){
	if(tr[x].l==tr[x].r) return tr[x].dat=min(tr[x].dat,k),void();
	PushDown(x);
	int mid=tr[x].l+tr[x].r>>1;
	if(pos<=mid) Set(x<<1,pos,k);
	else Set(x<<1|1,pos,k);
	PushUp(x);
}
inline void Modify(int x,int l,int r,int k){
	if(l>r) return ;
	if(l<=tr[x].l&&tr[x].r<=r) return Push(x,k);
	PushDown(x);
	int mid=tr[x].l+tr[x].r>>1;
	if(l<=mid) Modify(x<<1,l,r,k);
	if(r>mid) Modify(x<<1|1,l,r,k);
	PushUp(x);
}
inline int Query(int x,int l,int r){
	if(l>r) return inf;
	if(l<=tr[x].l&&tr[x].r<=r) return tr[x].dat;
	PushDown(x);
	int mid=tr[x].l+tr[x].r>>1,ans=inf;
	if(l<=mid) ans=min(ans,Query(x<<1,l,r));
	if(r>mid) ans=min(ans,Query(x<<1|1,l,r));
	return ans;
}

int a[N],f[N],n,p,k;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>p>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	a[++n]=inf;

	int ans=0;
	for(int i=1;i<p;i++) if(a[i]>=a[p]) ans++;
	
	vector<int> val(a,a+n+1);
	sort(val.begin(),val.end());
	val.erase(unique(val.begin(),val.end()));
	for(int i=1;i<=n;i++) a[i]=lower_bound(val.begin(),val.end(),a[i])-val.begin();

	f[p]=0;
	for(int i=p+1;i<=n;i++) f[i]=inf;
	for(int o=1;o<=k;o++){
		Build(1,1,n);
		for(int i=p;i<=n;i++){
			int tmp=f[i];
			f[i]=Query(1,1,a[i]-1);
			Modify(1,1,a[i]-1,1);
			Set(1,a[i],tmp);
		}
	}
	ans+=f[n];
	
	cout<<(ans<inf/2?ans:-1)<<endl;

	return 0;
}
```

### 66. Routes

æˆ‘æ“æˆ‘æ€ä¹ˆèŠ±äº†æ•´æ•´ä¸¤å¤©æ—¶é—´æ„è¯†åˆ°è‡ªå·±æ˜¯ä¸ªå‚»é€¼ã€‚

ä»¥ä¸‹è§„å®š $d(u,v),f(p,q),g(u,p)$ åˆ†åˆ«è¡¨ç¤ºç‚¹ $u$ åˆ°ç‚¹ $v$ï¼Œé¢œè‰² $p$ åˆ°é¢œè‰² $q$ï¼Œç‚¹ $u$ åˆ°é¢œè‰² $p$ çš„æœ€çŸ­è·¯ï¼Œ$c_u$ è¡¨ç¤ºç‚¹ $u$ çš„é¢œè‰²ã€‚

é¦–å…ˆæ˜¾ç„¶æœ‰ $f(c_u,p)\leq g(u,p)\leq f(c_u,p)+1$ï¼Œä»è€Œæœ‰ $f(c_u,c_v)\leq d(u,v)\leq f(c_u,c_v)+2$ã€‚

å…ˆå‡è®¾æ‰€æœ‰ç‚¹å¯¹éƒ½ç»è¿‡é£æœºè½¬ç§»è¿‡ä¹‹ä¸Šä¸€æ¬¡ï¼Œåé¢å¯ä»¥å†èŠ± $O(nk)$ çš„æ—¶é—´ä¿®æ­£ï¼Œå› ä¸ºå•ç»„ç­”æ¡ˆæ˜¾ç„¶å­˜åœ¨ä¸Šç•Œ $2k-1$ã€‚

è€ƒè™‘æšä¸¾ $u\rightarrow v$ ä¸­ç»è¿‡çš„ä¸­è½¬é¢œè‰²ï¼Œå³æœ‰ $\displaystyle d(u,v)=\min_p g(u,p)+g(v,p)+1=0/1/2+\min_pf(c_u,p)+f(p,c_v)+1$ã€‚

ç”±äºé¢œè‰²æ•°æ˜¯æå°‘çš„ï¼Œè€ƒè™‘æšä¸¾ $c_u,c_v$ï¼Œå¯¹ $d(u,v)=0/1/2+f(c_u,c_v)$ åˆ†åˆ«è®¡æ•°ã€‚

è®¾æ©ç  $\displaystyle s_u=\{p|g(u,p)=f(c_u,p)\},m_\Delta=\{p|f(c_u,p)+f(p,c_v)+\Delta=f(c_v,c_v)\}$ï¼š

- é‚£ä¹ˆ $d(u,v)=f(c_u,c_v)$ çš„æ¡ä»¶å°±æ˜¯ $\displaystyle s_u \cap s_v\cap m_0\neq \varnothing$ã€‚è€ƒè™‘æšä¸¾ $c_u$ å’Œ $v$ï¼Œä»¥åŠé¢„å¤„ç†å‡º $s_u$ çš„é«˜ç»´å‰ç¼€å’Œï¼Œåˆ™æ»¡è¶³æ¡ä»¶çš„ $(u,v)$ å¯¹æ•°æ€»ä½“å¯ä»¥åœ¨ $O(k^22^k+nk)$ çš„æ—¶é—´è®¡ç®—ã€‚
- ç±»ä¼¼åœ° $d(u,v)=f(c_u,c_v)+1$ çš„æ¡ä»¶ç­‰ä»·äº $\displaystyle (s_u \oplus s_v)\cap m_0\neq \varnothing$ æˆ– $\displaystyle s_u \cap s_v\cap m_1\neq \varnothing$ã€‚è¿™ä¸ªä¸æ˜¯å¾ˆå¥½æ±‚ï¼Œè€ƒè™‘ä» $d(u,v)=f(c_u,c_v)+0/2$ å®¹æ–¥å¾—å‡ºã€‚
- è€Œ $d(u,v)=f(c_u,c_v)+2$ çš„æ¡ä»¶æ˜¯ $\displaystyle (s_u \cup s_v)\cap m_0 = \varnothing$ ä¸” $\displaystyle s_u \cap s_v\cap m_1 = \varnothing$ã€‚è¿™ä¸ªå¯ä»¥å’Œ $d(u,v)=f(c_u,c_v)$ ç±»ä¼¼çš„é€šè¿‡ä½è¿ç®—æŠ€å·§åœ¨ç›¸åŒçš„æ—¶é—´å¤æ‚åº¦å†…è®¡ç®—å¾—åˆ°ã€‚

æ—¶é—´å¤æ‚åº¦ $O(k^3+nk+k^22^k)$ï¼Œä»£ç çœ‹èµ·æ¥å› ä¸ºå†…å­˜è®¿é—®çš„åŸå› å¸¸æ•°å¾ˆå¤§ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=1e6+9;
const int K=2e1+9;
const int S=(1<<16)+9;
const int inf=1e9+7;

string s[N];
int st[N],n,m,k;

vector<int> p[K];
vector<array<int,2>> e[N+K];
int bel[N],d[K][N+K],c[K][K],v[K][S],sta[N],m1[K][K],m2[K][K];
inline void BFS(int s,int *dis){
	deque<int> q;
	vector<int> vis(n+k+1,0);
	for(int i=1;i<=n+k;i++) dis[i]=inf;
	dis[s]=0;
	q.push_back(s);
	while(q.size()){
		int x=q.front();
		q.pop_front();
		if(vis[x]) continue ;
		vis[x]=1;
		for(auto p:e[x]){
			if(dis[x]+p[1]<dis[p[0]]){
				dis[p[0]]=dis[x]+p[1];
				if(!p[1]) q.push_front(p[0]);
				else q.push_back(p[0]);
			}
		}
	}
}
inline int Dist(int x,int y){
	if(bel[x]==bel[y]) return x!=y;
	if(bel[x]>bel[y]) swap(x,y);
	if(m1[bel[x]][bel[y]]&(sta[x]&sta[y])) return c[bel[x]][bel[y]];
	else if(m1[bel[x]][bel[y]]&(sta[x]|sta[y])) return c[bel[x]][bel[y]]+1;
	else if(m2[bel[x]][bel[y]]&(sta[x]&sta[y])) return c[bel[x]][bel[y]]+1;
	else return c[bel[x]][bel[y]]+2;
}

inline ll Solve(){
	cin>>n>>m>>k;
	st[0]=1;
	for(int i=1;i<=m;i++){
		cin>>s[i];
		st[i]=st[i-1]+s[i-1].size();
		for(int j=0;j<s[i].size();j++){
			if(j){
				e[st[i]+j].push_back({st[i]+j-1,1});
				e[st[i]+j-1].push_back({st[i]+j,1});
			}
			bel[st[i]+j]=s[i][j]-'a'+1;
			e[st[i]+j].push_back({n+bel[st[i]+j],1});
			e[n+bel[st[i]+j]].push_back({st[i]+j,0});
		}
	}
	for(int i=1;i<=k;i++) BFS(n+i,d[i]);
	for(int i=1;i<=k;i++){
		for(int j=1;j<=k;j++) c[i][j]=d[i][n+j]-(i!=j);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++){
			sta[i]|=(d[j][i]==c[j][bel[i]])<<j-1;
		}
		v[bel[i]][sta[i]]++;
		p[bel[i]].push_back(i);
	}

	ll ans=0;
	for(int i=1;i<=k;i++){
		ans+=1ll*p[i].size()*(p[i].size()-1)/2;
		for(int j=0;j<k;j++){
			for(int t=0;t<(1<<k);t++) if(~t>>j&1) v[i][t|(1<<j)]+=v[i][t];
		}
		for(int j=i+1;j<=k;j++){
			for(int t=1;t<=k;t++){
				m1[i][j]|=(c[i][j]==c[i][t]+c[t][j]+1)<<t-1;
				m2[i][j]|=(c[i][j]+1==c[i][t]+c[t][j]+1)<<t-1;
			}
			for(int x:p[j]){
				ll c0=p[i].size()-v[i][(1<<k)-1^m1[i][j]&sta[x]];
				ll c2=v[i][(1<<k)-1^m1[i][j]^m2[i][j]&sta[x]];
				ll c1=p[i].size()-c0-c2;
				ans+=c0*c[i][j]+c1*(c[i][j]+1)+c2*(c[i][j]+2);
			}
		}
	}

	for(int i=1;i<=m;i++){
		for(int j=0;j<s[i].size();j++){
			for(int t=max(0,j-2*k);t<j;t++){
				ans-=Dist(st[i]+t,st[i]+j);
				ans+=min(Dist(st[i]+t,st[i]+j),j-t);
			}
		}
	}

	for(int i=1;i<=k;i++){
		for(int j=1;j<=n+k;j++) d[i][j]=0;
		for(int j=0;j<(1<<k);j++) v[i][j]=0;
		for(int j=1;j<=k;j++) c[i][j]=m1[i][j]=m2[i][j]=0;
		p[i].clear(),p[i].shrink_to_fit();
	}
	for(int i=1;i<=n+k;i++) e[i].clear(),e[i].shrink_to_fit();
	for(int i=1;i<=n;i++) bel[i]=sta[i]=0;
	for(int i=1;i<=m;i++) s[i].clear(),s[i].shrink_to_fit();

	return ans;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int T;
	cin>>T;
	for(int o=1;o<=T;o++) cout<<"Case #"<<o<<": "<<Solve()<<endl;

	return 0;
}
```

### 67. One, Two, Three

å‘ƒå‘ƒé¦–å…ˆå› ä¸ºæ˜¯ $(1,2,3)$ å’Œ $(3,2,1)$ï¼Œæ‰€ä»¥è‚¯å®š $2$ æ˜¯ç‰¹æ®Šçš„ã€‚

è€ƒè™‘å…ˆè®© $(1,3),(3,1)$ åŒ¹é…æˆåŒºé—´ï¼Œæœ€åå†å¾€é‡Œé¢æ”¾ $2$ã€‚å‡è®¾é€‰äº† $x$ å¯¹ $(1,3)$ ä»¥åŠ $y$ å¯¹ $(3,1)$ï¼Œé‚£ä¹ˆå¤„äºè´ªå¿ƒçš„ç›®çš„ï¼Œç”¨äºåŒ¹é…çš„ç†åº”æ˜¯å‰ $x$ ä¸ª $1$ å‰ $y$ ä¸ª $3$ï¼Œä»¥åŠå $y$ ä¸ª $1$ å $x$ ä¸ª $3$ã€‚åŒæ—¶æˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡è°ƒæ•´ä½¿å¾— $(1,3)$ å¯¹ä¹‹é—´ï¼Œ$(3,1)$ å¯¹ä¹‹é—´äº’ç›¸ä¸æ„æˆåŒ…å«å…³ç³»ï¼Œè€Œç­”æ¡ˆä¸å˜ã€‚

ä»¤ $\displaystyle c_{k}(l,r)=\sum_{i=l}^r[a_i=k],s_k(p)=c_k(1,p)$ã€‚

ç”±äºè¦å¯¹ $2$ åŒ¹é…ï¼Œè€ƒè™‘ Hall å®šç†ï¼Œè®¾ $f(l,r),g(l,r)$ åˆ†åˆ«è¡¨ç¤º $[l,r]$ å†… $(1,3)$ å¯¹å’Œ $(3,1)$ å¯¹çš„æ•°é‡ï¼š

- $f(l,r)+g(l,r)\leq c_2(l,r)$ã€‚
- $f(l,r)=\max(x-c_1(1,l-1)-c_3(r+1,n),0)$ã€‚
- $g(l,r)=\max(y-c_3(1,l-1)-c_1(r+1,n),0)$ã€‚

äºŒä¸‰å¼ä»£å…¥ä¸€å¼æ‹† max å¯ä»¥å¾—åˆ° $4$ æ¡é™åˆ¶ï¼š

- $0 \leq c_2(l,r)$ã€‚
- $x \leq c_2(l,r)+c_1(1,l-1)+c_3(r+1,n)$ã€‚
- $y\leq c_2(l,r)+c_3(1,l-1)+c_1(r+1,n)$ã€‚
- $x+y\leq c_2(l,r)+c_1(1,l-1)+c_3(r+1,n)+c_3(1,l-1)+c_1(r+1,n)$ã€‚

å°† $c_k$ æ‹†æˆ $s_k$ ä¹‹åå¯ä»¥å¾—åˆ° $l,r$ å¯¹ $x,y,x+y$ çš„é™åˆ¶ï¼Œå¯¹æœ‰å…³ $l$ çš„å¼å­æ±‚å‰ç¼€æœ€å€¼å¯ä»¥å¾—åˆ° $x,y,x+y$ çš„ä¸Šç•Œï¼Œæ ¹æ® Hall å®šç†ï¼Œéšä¾¿æ‰¾ä¸€ç»„ $(x_0,y_0)$ å°±æ˜¯å¯¹çš„ã€‚

æ„é€ è§£è€ƒè™‘å°†æ‰€æœ‰ $(1,3)$ å’Œ $(3,1)$ å¯¹æŠ½å‡ºæ¥ï¼Œå¯¹æ‰€æœ‰ $2$ ä»å·¦åˆ°å³ä¼˜å…ˆåŒ¹é…å³ç«¯ç‚¹æœ€å·¦çš„å³å¯ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ï¼Œç“¶é¢ˆåœ¨äºæ„é€ è§£ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=6e5+9;
const int inf=1e9+7;

int a[N],rk[N],cnt[4][N],p[4][N],n;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];

	int x=inf,y=inf,xy=inf,lx=inf,ly=inf,lxy=inf;
	for(int i=1;i<=n;i++){
		for(int j:{1,2,3}) cnt[j][i]=cnt[j][i-1];
		p[a[i]][rk[i]=++cnt[a[i]][i]]=i;
	}
	x=y=xy=min(cnt[1][n],min(cnt[2][n],cnt[3][n]));
	for(int i=1;i<=n;i++){
		lx=min(lx,-cnt[2][i-1]+cnt[1][i-1]);
		ly=min(ly,-cnt[2][i-1]+cnt[3][i-1]);
		lxy=min(lxy,-cnt[2][i-1]+cnt[1][i-1]+cnt[3][i-1]);
		x=min(x,lx+cnt[2][i]-cnt[3][i]+cnt[3][n]);
		y=min(y,ly+cnt[2][i]-cnt[1][i]+cnt[1][n]);
		xy=min(xy,lxy+cnt[2][i]-cnt[3][i]+cnt[3][n]-cnt[1][i]+cnt[1][n]);
	}
	xy=min(xy,x+y),x=min(x,xy),y=xy-x;

	cout<<x+y<<endl;
	priority_queue<array<int,2>> q;
	for(int i=1;i<=n;i++){
		if(a[i]==1){
			if(rk[i]<=x) q.push({-p[3][cnt[3][n]-(x-rk[i]+1)+1],-i});
		}else if(a[i]==3){
			if(rk[i]<=y) q.push({-p[1][cnt[1][n]-(y-rk[i]+1)+1],-i});
		}else if(a[i]==2){
			if(q.size()){
				cout<<-q.top()[1]-1<<' '<<i-1<<' '<<-q.top()[0]-1<<endl;
				q.pop();
			}
		}
	}

	return 0;
}
```

### 68. Lonely King

é¦–å…ˆæœ€ä¼˜ç¼©è¾¹æ–¹å¼è‚¯å®šæ˜¯ç›´æ¥ç¼©åˆ°å¶å­ï¼Œå› æ­¤æ•´ä½“å½¢æ€ç±»ä¼¼å¯¹è¾¹è¿›è¡Œå‰–åˆ†ã€‚

è®¾ $f_x(k)$ è¡¨ç¤ºç»è¿‡ $x$ è¿å‡ºå»çš„è¾¹è¿åˆ°çš„ç‚¹ç‚¹æƒä¸º $k$ æ—¶ç­”æ¡ˆæœ€å°å€¼ï¼Œæœ‰è½¬ç§»ï¼š$\displaystyle f_x(k)=\min_{x\rightarrow y}( f_y(k)+\sum_{z\neq y,x\rightarrow z}f_z(c_x)$ã€‚

é‚£ä¹ˆæ˜¾ç„¶åœ°ï¼Œ$f_x(k)$ æ˜¯ä¸‹å‡¸çš„ï¼Œè‡³æ­¤å¯ä»¥ä½¿ç”¨ç›´æ¥ä¸€äº›æ‰‹æ³•ç›´æ¥ç»´æŠ¤ã€‚

è€ƒè™‘å¯¹æ¯ä¸ªèŠ‚ç‚¹ä½¿ç”¨æè¶…çº¿æ®µæ ‘ç»´æŠ¤ $f_x(k)$ï¼Œéœ€è¦çš„æ“ä½œæ˜¯å…¨å±€å‡å’Œåˆå¹¶ï¼Œå¯ä»¥ç›´æ¥æ‰“ tagï¼Œä¹Ÿå¯ä»¥è®°å½•åå·®å€¼ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=2e5+9;
const int inf=1e9+7;
const ll lnf=1e18;
const int V=1e6;

struct Line{
	ll k,b;
	Line(){}
	Line(ll _k,ll _b){k=_k,b=_b;}
	inline ll operator ()(ll x){return k*x+b;}
};

struct Node{
	ll tag;
	int lc,rc;
	Line f=Line(inf,lnf);
}tr[N<<6];

int cnt;
inline int Allc(){return ++cnt;}
inline void Push(int &x,ll k){
	if(!x) return ;
	tr[x].f.b+=k,tr[x].tag+=k;
}
inline void PushDown(int x){
	if(tr[x].tag){
		Push(tr[x].lc,tr[x].tag);
		Push(tr[x].rc,tr[x].tag);
		tr[x].tag=0;
	}
}
inline bool Beat(int L,int R,Line f,Line g){return f(L)<g(L)&&f(R)<g(R);}
inline bool NoUse(int L,int R,Line f,Line g){return f(L)>=g(L)&&f(R)>=g(R);}
inline bool Invalid(Line f){return f.k>=inf/10||f.b>=lnf/10;}
inline void Update(int &x,int L,int R,int l,int r,Line f){
	if(!x) x=Allc();
	if(l<=L&&R<=r){
		if(L<R) PushDown(x);
		if(Beat(L,R,f,tr[x].f)) tr[x].f=f,tr[x].tag=0;
		else if(L<R){
			int mid=L+R>>1;
			if(!NoUse(L,mid,f,tr[x].f)) Update(tr[x].lc,L,mid,l,r,f);
			if(!NoUse(mid+1,R,f,tr[x].f)) Update(tr[x].rc,mid+1,R,l,r,f);
		}
		return ;
	}
	PushDown(x);
	int mid=L+R>>1;
	if(l<=mid) Update(tr[x].lc,L,mid,l,r,f);
	if(r>mid) Update(tr[x].rc,mid+1,R,l,r,f);
}
inline ll Min(int x,int L,int R,int pos){
	if(!x) return lnf;
	if(L==R) return tr[x].f(pos);
	PushDown(x);
	int mid=L+R>>1;
	if(pos<=mid) return min(tr[x].f(pos),Min(tr[x].lc,L,mid,pos));
	else return min(tr[x].f(pos),Min(tr[x].rc,mid+1,R,pos));
}
inline void Merge(int &x,int y,int L,int R){
	if(!y||Invalid(tr[y].f)) return ;
	if(!x||Invalid(tr[x].f)) return x=y,void();
	Update(x,L,R,L,R,tr[y].f);
	if(L==R) return ;
	int mid=L+R>>1;
	PushDown(x),PushDown(y);
	Merge(tr[x].lc,tr[y].lc,L,mid);
	Merge(tr[x].rc,tr[y].rc,mid+1,R);
}

vector<int> e[N];
int c[N],fa[N],root[N],n;
inline void Solve(int x){
	if(!e[x].size()){
		Update(root[x],1,V,1,V,Line(c[x],0));
	}else{
		ll sum=0;
		for(int y:e[x]){
			Solve(y);
			ll t=Min(root[y],1,V,c[x]);
			sum+=t;
			Push(root[y],-t);
			Merge(root[x],root[y],1,V);
		}
		Push(root[x],sum);
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=2;i<=n;i++) cin>>fa[i],e[fa[i]].push_back(i);
	for(int i=1;i<=n;i++) cin>>c[i];

	if(n==1){
		cout<<0<<endl;
		return 0;
	}

	Solve(1);

	cout<<Min(root[1],1,V,c[1])<<endl;

	return 0;
}
```

### 69. Beautiful Sequence

é¦–å…ˆç­”æ¡ˆå¯ä»¥åˆ»ç”»æˆ $\displaystyle n-\sum_{i=1}^{n-1}[a_i\neq a_{i+1}]+[a_{i-1}>a_i<a_{i+1}]$ï¼ŒåŸç†æ˜¯ç›¸é‚»çš„ä¸åŒå€¼å°çš„é‚£ä¸ªè‚¯å®šå€’é—­äº†ï¼Œä½†æ˜¯ä¸€ä¸ªç‚¹ä¸ä¼šå€’é—­ä¸¤æ¬¡ã€‚

é‚£ä¹ˆå‡è®¾å½“å‰æœ‰ $c$ ä¸ªä¸€æ ·çš„æ•°ï¼Œè°ƒæ•´æ³•å¯çŸ¥ï¼Œ**åŸºæœ¬ä¸Š**é™¤äº†å¡«æˆ $c$ ä¸ªé•¿åº¦ä¸º $1$ çš„è°·æ®µæˆ–å¡« $1$ ä¸ªé•¿åº¦ä¸º $c$ çš„æ®µä»¥å¤–å‡ä¸ä¼˜ã€‚ç‰¹åˆ«åœ°ï¼Œå¡«æˆ $c$ ä¸ªé•¿åº¦ä¸º $1$ çš„è°·æ®µæœ‰ $1$ çš„é¢å¤–è´¡çŒ®ã€‚ä¸ä»ä¸Šè¿°å¼å­åˆ»ç”»è¿™ç‚¹åˆ™æ²¡é‚£ä¹ˆæ˜¾ç„¶ã€‚

è€ƒè™‘ä»å¤§åˆ°å°å¡«æ•°ï¼Œé‚£ä¹ˆå¡« $c$ ä¸ªé•¿åº¦ä¸º $1$ çš„è°·æ®µç›¸å½“äºåˆå¹¶ $c+1$ ä¸ªè¿ç»­æ®µï¼Œè€Œå¡« $1$ ä¸ªé•¿åº¦ä¸º $c$ çš„æ®µè‡³å¤šå¯ä»¥æ–°å¢ä¸€ä¸ªè¿ç»­æ®µï¼Œæœ€åè¿ç»­æ®µæœ‰å¤šä¸ªç›´æ¥åˆå¹¶æˆä¸€ä¸ªå³å¯ã€‚

å› æ­¤é—®é¢˜è½¬åŒ–ä¸ºï¼Œç»™å®šåºåˆ— $a_i$ï¼Œæ±‚ $\sum x_i$ æœ€å¤§å€¼ä½¿å¾— $\displaystyle \forall i,x_i\in\{0,1\},\sum_{j=1}^i x_ia_i\leq i$ã€‚è€ƒè™‘ç›´æ¥è´ªå¿ƒï¼Œä» $i-1$ æ¨åˆ° $i$ çš„æ—¶å€™ï¼Œèƒ½ç›´æ¥åŠ å…¥ $a_i$ è‚¯å®šç›´æ¥åŠ å…¥ $a_i$ äº†ï¼Œ è€ƒè™‘æ— æ³•åŠ å…¥ $a_i$ è‚¯å®šæ˜¯å› ä¸º $i-1$ çš„ $\sum x_ia_i$ å¤ªå¤§äº†ï¼Œå› æ­¤æ¯æ¬¡è´ªå¿ƒè€ƒè™‘æŠŠ $\sum x_ia_i$ å½“ä½œç¬¬äºŒå…³é”®å­—ï¼Œå¦‚æœæ— æ³•ç›´æ¥åŠ å…¥å°±å°è¯•æŠŠ $i-1$ çš„ç­”æ¡ˆä¸­æœ€å¤§å€¼æ¢æ‰ï¼Œä¸éš¾å‘ç°è¿™æ ·ä¸å½±å“ç­”æ¡ˆæ­£ç¡®æ€§ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=3e5+9;

int a[N],c[N],n,m;

inline void Solve(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];

	vector<int> val(a,a+n+1);
	sort(val.begin(),val.end());
	val.erase(unique(val.begin(),val.end()),val.end());
	m=val.size()-1;

	for(int i=1;i<=n;i++){
		c[lower_bound(val.begin(),val.end(),a[i])-val.begin()]++;
	}
	
	int ans=n-m+1,sum=0;
	priority_queue<int> q;
	for(int i=m;i>=1;i--){
		q.push(c[i]+1),sum+=c[i]+1,ans++;
		if(sum>=m-i+1) sum-=q.top(),ans--,q.pop();
		c[i]=0;
	}

	cout<<ans<<endl;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int T;
	cin>>T;
	while(T--) Solve();

	return 0;
}
```

### 73. Sets May Be Good

è€ƒè™‘æŠŠç­”æ¡ˆåˆ»ç”»æˆï¼š$\displaystyle \sum_{x\in\Z_2^n} (\sum_{(i,j)\in E} x_ix_j)\bmod 2$ï¼Œè¿™æ˜¯äºŒæ¬¡å‹ï¼Œä»¤ $A$ ä¸ºåŸå›¾çš„é‚»æ¥çŸ©é˜µï¼Œé‚£ä¹ˆè¯¥å¼ç­‰åŒäº $\displaystyle \sum_{x\in\Z_2^n} x^TAx\bmod 2$ã€‚

è€ƒè™‘å°†å˜æ¢ $R$ ä½œç”¨äº $x$ï¼Œä½¿å¾— $x$ ä»ç„¶èƒ½å¤Ÿå–é $\Z_2^n$ï¼Œå³ï¼š$\displaystyle \sum_{x\in\Z_2^n} (Rx)^TA(Rx)\bmod 2=\sum_{x\in\Z_2^n} x^T(R^TAR)x\bmod 2$ã€‚

è¿™è¯´æ˜æŠŠ $A$ å˜æ¢åˆ° $R^TAR$ ç­”æ¡ˆä»æ—§ä¸å˜ï¼Œç»„åˆæ„ä¹‰å°±æ˜¯æ–½åŠ åŸºæœ¬è¡Œå˜æ¢ä¹‹åå†æ–½åŠ ç›¸åŒçš„åŸºæœ¬åˆ—å˜æ¢ã€‚

å› æ­¤è€ƒè™‘æ¶ˆå…ƒï¼š

- é¦–å…ˆï¼Œå…ˆå°† $A_{1,i}$ ç¿»æŠ˜åˆ° $A_{i,1}$ ä¸Šï¼Œå³ $A_{i,1}\leftarrow A_{1,i}+A_{i,1}$ï¼Œ$A_{1,i}\leftarrow 0$ã€‚
- ç„¶åæ‰¾åˆ°è¡Œ $i$ ä½¿å¾— $A_{i,1}\neq 0$ï¼Œå°†å…¶ä¸ç¬¬ $2$ è¡Œäº¤æ¢ï¼ŒåŒæ—¶äº¤æ¢ç¬¬ $2$ åˆ—ä¸ç¬¬ $i$ åˆ—ã€‚
- ä¹‹åï¼Œå¯¹äºç¬¬ $3$ è¡ŒåŠä»¥åçš„æ‰€æœ‰ $A_{i,1}\neq 0$ çš„è¡Œ $i$ï¼ŒæŠŠç¬¬ $2$ è¡Œä¸ç¬¬ $i$ è¡Œç›¸æ¶ˆï¼Œå³ $A_{i,j}\leftarrow A_{i,j}+A_{2,j}$ã€‚åŒæ—¶æŠŠç¬¬ $2$ åˆ—åŠ åˆ°ç¬¬ $i$ åˆ—ä¸Šã€‚

- æ­¤æ—¶ç¬¬ $1$ åˆ—åªæœ‰ $A_{1,1},A_{2,1}$ æœ‰å€¼ï¼Œç¬¬ $1$ è¡Œåªæœ‰ $A_{1,1}$ æœ‰å€¼ï¼Œé€’å½’åœ°æ¶ˆå…ƒå³å¯ã€‚

æœ€ååªæœ‰ $A_{i,i},A_{i+1,i}$ æœ‰å€¼ï¼Œé‚£ä¹ˆæ­¤æ—¶å½¢æ€å°±æ˜¯ä¸€æ¡æœ‰è‡ªç¯çš„é“¾ï¼Œå¯ä»¥é€šè¿‡ç®€å•çš„ DP è§£å†³ã€‚

æ¶ˆå…ƒå¯ä»¥ç”¨ bitset åŠ ä»¥ä¼˜åŒ–ï¼Œæ—¶é—´å¤æ‚åº¦ $O(\dfrac {n^3}w)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=1e3+9;
const int mod=998244353;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
inline int Inv(int x){return QPow(x,mod-2);}

int f[N][2][2],n,m;
bitset<N> a[N];

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		a[u].flip(v);
	}

	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++) a[j][i]=a[j][i]^a[i][j],a[i][j]=0;
		int p=i+1;
		while(p<=n&&!a[p][i]) p++;
		if(p>n) continue ;
		else if(p!=i+1){
			swap(a[i+1],a[p]);
			for(int j=1;j<=n;j++){
				a[j][i+1]=a[j][p]^a[j][i+1];
				a[j][p]=a[j][p]^a[j][i+1];
				a[j][i+1]=a[j][p]^a[j][i+1];
			}
		}
		bitset<N> b;
		for(int j=i+2;j<=n;j++){
			if(!a[j][i]) continue ;
			a[j]^=a[i+1];
			b.set(j);
		}
		for(int j=1;j<=n;j++) if(a[j][i+1]) a[j]^=b;
	}

	f[0][0][0]=1;
	for(int i=1;i<=n;i++){
		for(int s:{0,1}){
			for(int p:{0,1}){
				for(int q:{0,1}){
					AddAs(f[i][s^(q&a[i][i])^(p&q&a[i][i-1])][q],f[i-1][s][p]);
				}
			}
		}
	}
	
	int ans=0;
	for(int p:{0,1}) AddAs(ans,f[n][0][p]);

	cout<<ans<<endl;

	return 0;
}
```

### 77. Honorable Mention

é¦–å…ˆä»¥ $k$ ä¸ºè‡ªå˜é‡ï¼Œ$[l,r]$ çš„ $k$ å­æ®µå’Œæ˜¯å‡¸çš„ï¼Œæ„Ÿæ€§ç†è§£å°±æ˜¯å¦‚æœä¸¤ä¸ªè¾ƒå¤§åŒºé—´æœ‰äº¤å°±å¯ä»¥ç›´æ¥åˆå¹¶ï¼Œæ‰€ä»¥ä¸€å®šæ˜¯ä»å¤§åˆ°å°é€‰å‡ºè‹¥å¹²æ®µè¿ç»­åŒºé—´ï¼Œç„¶åå°†è¿™äº›åŒºé—´åˆ†è£‚ï¼Œæœ€åå†é€‰ä¸€äº›è´Ÿçš„å•ç‚¹ï¼Œä»£æ•°è¯æ˜æ˜¯å®¹æ˜“çš„ã€‚

å»ºç«‹é™æ€çš„çº¿æ®µæ ‘ç»´æŠ¤è¿™ä¸ªå‡¸åŒ…ï¼Œå¯¹äºæ¯æ¬¡è¯¢é—®ï¼Œè€ƒè™‘ wqs äºŒåˆ†æ–œç‡åˆ‡å‡¸åŒ…ï¼Œä»¥ç­”æ¡ˆä¸ºç¬¬ä¸€å…³é”®å­—ï¼Œæ®µæ•°ä¸ºç¬¬äºŒå…³é”®å­— DP é€‰å–æœ€å¤§å€¼ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n\log^2 n\log V)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=5e4+9;
const int V=1e9;
const ll inf=1e18,hnf=1e12;

int a[N],n,q;

struct Node{
	int l,r;
	vector<ll> f[2][2],df[2][2];
}tr[N<<2];

inline vector<ll> Shift(vector<ll> f,int k){
	f.erase(f.begin(),f.begin()+k);
	return f;
}
inline vector<ll> Merge(vector<ll> f,vector<ll> g){
	adjacent_difference(f.begin(),f.end(),f.begin());
	adjacent_difference(g.begin(),g.end(),g.begin());
	vector<ll> h(f.size()+g.size()-1);
	h[0]=f[0]+g[0];
	merge(f.begin()+1,f.end(),g.begin()+1,g.end(),h.begin()+1,greater<ll>());
	partial_sum(h.begin(),h.end(),h.begin());
	return h;
}
inline void ChMax(vector<ll> &f,vector<ll> g){
	int len=max(f.size(),g.size());
	f.resize(len,LLONG_MIN);
	g.resize(len,LLONG_MIN);
	for(int i=0;i<len;i++) f[i]=max(f[i],g[i]);
}

inline void DF(int x){
	for(int i:{0,1}){
		for(int j:{0,1}){
			tr[x].df[i][j].resize(tr[x].f[i][j].size());
			adjacent_difference(tr[x].f[i][j].begin(),tr[x].f[i][j].end(),tr[x].df[i][j].begin());
			tr[x].df[i][j][0]=LLONG_MAX;
		}
	}
}
inline void PushUp(int x){
	for(int i:{0,1}){
		for(int j:{0,1}){
			for(int k:{0,1}){
				ChMax(tr[x].f[i][j],Shift(Merge(tr[x<<1].f[i][k],tr[x<<1|1].f[k][j]),k));
			}
		}
	}
	DF(x);
}

inline void Build(int x,int l,int r){
	tr[x].l=l,tr[x].r=r;
	if(tr[x].l==tr[x].r){
		for(int i:{0,1}) for(int j:{0,1}) tr[x].f[i][j]={-(i|j)*hnf,a[l]};
		DF(x);
		return ;
	}
	int mid=tr[x].l+tr[x].r>>1;
	Build(x<<1,l,mid),Build(x<<1|1,mid+1,r);
	PushUp(x);
}

struct Data{
	array<ll,2> f[2][2];
	friend inline Data operator +(Data x,Data y){
		Data z;
		for(int i:{0,1}){
			for(int j:{0,1}){
				z.f[i][j]={LLONG_MIN,0};
				for(int k:{0,1}){
					z.f[i][j]=max(z.f[i][j],{x.f[i][k][0]+y.f[k][j][0],x.f[i][k][1]+y.f[k][j][1]-k});
				}
			}
		}
		return z;
	}
};

inline Data GetData(int x,ll dlt){
	Data t;
	for(int i:{0,1}){
		for(int j:{0,1}){
			int p=upper_bound(tr[x].df[i][j].begin(),tr[x].df[i][j].end(),dlt,greater<ll>())-tr[x].df[i][j].begin()-1;
			t.f[i][j]={(i||j)&&!p||!~p?-inf:tr[x].f[i][j][p]-p*dlt+i*dlt,p};
		}
	}
	return t;
}
inline Data Query(int x,int l,int r,ll dlt){
	if(l<=tr[x].l&&tr[x].r<=r) return GetData(x,dlt);
	int mid=tr[x].l+tr[x].r>>1;
	if(r<=mid) return Query(x<<1,l,r,dlt);
	else if(l>mid) return Query(x<<1|1,l,r,dlt);
	else return Query(x<<1,l,r,dlt)+Query(x<<1|1,l,r,dlt);
}
inline ll Calc(int l,int r,int k){
	ll L=-V,R=V;
	while(L+1<R){
		ll mid=L+R>>1;
		if(Query(1,l,r,mid).f[0][0][1]>=k) L=mid;
		else R=mid;
	}
	return Query(1,l,r,L).f[0][0][0]+1ll*L*k;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i];

	Build(1,1,n);
	while(q--){
		int l,r,k;
		cin>>l>>r>>k;
		cout<<Calc(l,r,k)<<endl;
	}

	return 0;
}
```

