# T1 - 胡可

## 题面

### 题目大意

给定一个有 $n$ 个点和 $m$ 条边简单带权无向图，其中有一些点是关键点，定义一条路径的费用是以路径上相邻两个关键点为端点的子路径长度的最大值。

共 $q$ 次询问，每次求 $u_i,v_i$ 两点之间路径费用的最小值，保证 $u_i,v_i$ 均为关键点。

### 数据范围



## 题解

```cpp
#include<bits/stdc++.h>

using namespace std;

ifstream fin("hukk.in");
ofstream fout("hukk.out");
#define cin fin
#define cout fout
#define endl '\n'

#define fir(x) (x).first
#define sec(x) (x).second
using pii=pair<int,int>;
using ll=long long;
const ll inf=1e18+7;
const int N=6e5+9;
const int lgN=2e1;

int fi[N],ne[N<<3],to[N<<3],w[N<<3],adj;
inline void AddEdge(int x,int y,int z){
    ne[++adj]=fi[x];
    fi[x]=adj;
    to[adj]=y;
    w[adj]=z;
}

int a[N],u[N],v[N],n,m,q;

ll dis[N];
int vis[N],bel[N];
vector<tuple<ll,int,int>> e;
inline void Dij(){
    for(int i=1;i<=n;i++) vis[i]=0,dis[i]=inf;
    priority_queue<pair<ll,int>> q;
    for(int i=1;i<=n;i++){
        if(!a[i]) continue ;
        bel[i]=i,dis[i]=0;
        q.push({0,i});
    }
    while(q.size()){
        int x=sec(q.top());
        q.pop();
        if(vis[x]) continue ;
        vis[x]=1;
        for(int i=fi[x];i;i=ne[i]){
            int y=to[i];
            if(dis[x]+w[i]<dis[y]){
                dis[y]=dis[x]+w[i];
                bel[y]=bel[x];
                q.push({-dis[y],y});
            }
        }
    }
}
inline void Link(){
    for(int x=1;x<=n;x++){
        for(int i=fi[x];i;i=ne[i]){
            int y=to[i];
            if(bel[x]==bel[y]) continue ;
            e.emplace_back(dis[x]+dis[y]+w[i],bel[x],bel[y]);
        }
    }
}
int f[N<<2];
inline int Find(int x){return f[x]==x?x:f[x]=Find(f[x]);}
inline void Merge(int x,int y){f[Find(y)]=Find(x);}
int fa[N<<2],dep[N<<2];
ll val[N<<2];
inline void DFS(int x){
    for(int i=fi[x];i;i=ne[i]){
        int y=to[i];
        if(fa[y]!=x) continue ;
        fa[y]=x;
        dep[y]=dep[x]+1;
        DFS(y);
    }
}
int anc[N<<2][lgN],root;
inline void InitLCA(){
    dep[root]=1,DFS(root);
    for(int i=1;i<=root;i++) anc[i][0]=fa[i];
    for(int k=1;k<lgN;k++){
        for(int i=1;i<=root;i++){
            anc[i][k]=anc[anc[i][k-1]][k-1];
        }
    }
}
inline int LCA(int x,int y){
    if(dep[x]<dep[y]) swap(x,y);
    for(int k=lgN-1;~k;k--) if(dep[anc[x][k]]>=dep[y]) x=anc[x][k];
    if(x==y) return x;
    for(int k=lgN-1;~k;k--) if(anc[x][k]!=anc[y][k]) x=anc[x][k],y=anc[y][k];
    return fa[x];
}
inline void InitT(){
    root=n;
    iota(f+1,f+n+n+1,1);
    sort(e.begin(),e.end());
    for(auto t:e){
        int u=get<1>(t),v=get<2>(t);
        if(Find(u)==Find(v)) continue ;
        ++root;
        fa[Find(u)]=fa[Find(v)]=root;
        AddEdge(root,Find(u),0),AddEdge(root,Find(v),0);
        Merge(root,u),Merge(root,v);
        val[root]=get<0>(t);
    }
}

signed main(){
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1,u,v,w;i<=m;i++){
        cin>>u>>v>>w;
        AddEdge(u,v,w);
        AddEdge(v,u,w);
    }

    Dij();
    Link();
    InitT();
    InitLCA();
    while(q--){
        int u,v;
        cin>>u>>v;
        cout<<val[LCA(u,v)]<<endl;
    }

    return 0;
}
```

# T2 - 深海湾

## 题面

### 题目大意

### 数据范围

题解

```cpp
#include<bits/stdc++.h>

using namespace std;

ifstream fin("lfxxx.in");
ofstream fout("lfxxx.out");
#define cin fin
#define cout fout
#define endl '\n'

#define fir(x) (x).first
#define sec(x) (x).second
using ll=long long;
const int N=6e5+9;
const int lgN=2e1;

int fi[N],ne[N<<1],to[N<<1],w[N<<1],adj;
inline void AddEdge(int x,int y,int z){
    ne[++adj]=fi[x];
    fi[x]=adj;
    to[adj]=y;
    w[adj]=z;
}

int elr[N<<1],pos[N],fa[N],p[N],ecnt,n,q;
ll dep[N];
inline void DFS(int x){
    elr[++ecnt]=x;
    pos[x]=ecnt;
    for(int i=fi[x];i;i=ne[i]){
        int y=to[i];
        if(y==fa[x]) continue ;
        fa[y]=x;
        dep[y]=dep[x]+w[i];
        DFS(y);
        elr[++ecnt]=x;
    }
}
int mn[N][lgN],lg[N];
inline void InitLCA(){
    for(int i=2;i<=ecnt;i++) lg[i]=lg[i>>1]+1;
    for(int i=1;i<=ecnt;i++) mn[i][0]=pos[elr[i]];
    for(int k=1;k<=lg[ecnt];k++){
        for(int i=1;i<=ecnt;i++) mn[i][k]=min(mn[i][k-1],mn[i+(1<<k-1)][k-1]);
    }
}
inline int LCA(int x,int y){
    x=pos[x],y=pos[y];
    if(x>y) swap(x,y);
    int k=lg[y-x+1];
    return elr[min(mn[x][k],mn[y-(1<<k)+1][k])];
}

inline vector<int> Extend(vector<int> v){
    sort(v.begin(),v.end(),[](int u,int v){return pos[u]<pos[v];});
    int tot=v.size();
    for(int i=1;i<tot;i++) v.push_back(LCA(v[i-1],v[i]));
    sort(v.begin(),v.end(),[](int u,int v){return pos[u]<pos[v];});
    v.erase(unique(v.begin(),v.end()),v.end());
    return v;
}
vector<pair<int,ll>> e[N];
int hson[N];
ll h[N],len[N],up[N];
inline void DFS1(int x){
    h[x]=0,hson[x]=0;
    for(auto p:e[x]){
        int y=fir(p);ll w=sec(p);
        if(y==fa[x]) continue ;
        fa[y]=x;
        len[y]=len[x]+w;
        DFS1(y);
        up[y]=w;
        h[x]=max(h[x],h[y]+up[y]);
        if(!hson[x]||h[y]+up[y]>h[hson[x]]+up[hson[x]]) hson[x]=y;
    }
}
int top[N],lf[N];
inline void DFS2(int x,int t){
    top[x]=t;
    if(hson[x]) DFS2(hson[x],t);
    else lf[x]=1;
    for(auto p:e[x]){
        int y=fir(p);
        if(y==fa[x]) continue ;
        if(y==hson[x]) continue ;
        DFS2(y,y);
    }
}
inline vector<int> Sort(vector<int> &v){
    vector<int> node=Extend(v);
    for(int i=1;i<node.size();i++){
        int u=LCA(node[i-1],node[i]),v=node[i];
        ll w=dep[v]-dep[u];
        e[u].emplace_back(v,w);
        e[v].emplace_back(u,w);
    }
    int root=node.front();
    fa[root]=0,DFS1(root);
    root=0;
    for(int i:v) if(!root||len[i]>len[root]) root=i;
    fa[root]=0,DFS1(root),DFS2(root,root);
    lf[root]=1,top[root]=0,up[root]=0;
    vector<int> leaf;
    for(int x:node) if(lf[x]) leaf.push_back(x);
    sort(leaf.begin(),leaf.end(),[&root](int x,int y)->bool{
        if(x==root) return 1;
        if(y==root) return 0;
        return h[top[x]]+up[top[x]]>h[top[y]]+up[top[y]];
    });
    for(int x:node) e[x].clear(),lf[x]=0;
    return leaf;
}
const int K=100;
inline ll Worth(vector<int> &v,int lim=K){
    ll sum=0;
    vector<int> node=Extend(v);
    for(int i=1;i<node.size();i++){
        int u=LCA(node[i-1],node[i]),v=node[i];
        ll w=dep[v]-dep[u];
        e[u].emplace_back(v,w);
        e[v].emplace_back(u,w);
    }
    int root=node.front();
    fa[root]=0,DFS1(root);
    root=0;
    for(int i:v) if(!root||len[i]>len[root]) root=i;
    fa[root]=0,DFS1(root),DFS2(root,root);
    lf[root]=1,top[root]=0,up[root]=0;
    vector<int> leaf;
    for(int x:node) if(lf[x]) leaf.push_back(x);
    sort(leaf.begin(),leaf.end(),[&root](int x,int y)->bool{
        if(x==root) return 1;
        if(y==root) return 0;
        return h[top[x]]+up[top[x]]>h[top[y]]+up[top[y]];
    });
    while(leaf.size()>lim) leaf.pop_back();
    for(int x:leaf) sum+=h[top[x]]+up[top[x]];
    for(int x:node) e[x].clear(),lf[x]=0;
    return sum;
}
inline vector<int> Merge(vector<int> a,vector<int> b){
    if(!a.size()) return b;
    if(!b.size()) return a;
    vector<int> tmp;
    tmp.insert(tmp.end(),a.begin(),a.end());
    tmp.insert(tmp.end(),b.begin(),b.end());
    tmp=Sort(tmp);
    while(tmp.size()>K) tmp.pop_back();
    return tmp;
}

const int B=100;
int blk[N],L[N],R[N],tot;
vector<int> st[N/B][lgN];
inline void Init(){
    for(int i=1;i<=n;i++) blk[i]=(i-1)/B+1;
    for(int i=1;i<=n;i++) R[blk[i]]=i;
    for(int i=n;i>=1;i--) L[blk[i]]=i;
    for(int i=1;i<=n;i++) st[blk[i]][0].push_back(p[i]);
    tot=blk[n];
    for(int i=1;i<=tot;i++) st[i][0]=Sort(st[i][0]);
    for(int k=1;k<=lg[tot];k++){
        for(int i=1;i<=tot-(1<<k)+1;i++) st[i][k]=Merge(st[i][k-1],st[i+(1<<k-1)][k-1]);
    }
}
inline vector<int> Get(int l,int r){
    vector<int> res;
    if(blk[l]==blk[r]){
        for(int i=l;i<=r;i++) res.push_back(p[i]);
        return Sort(res);
    }
    for(int i=l;i<=R[blk[l]];i++) res.push_back(p[i]);
    for(int i=L[blk[r]];i<=r;i++) res.push_back(p[i]);
    res=Sort(res);
    if(blk[l]+1<blk[r]){
        int ll=blk[l]+1,rr=blk[r]-1,k=lg[rr-ll+1];
        res=Merge(res,st[ll][k]);
        res=Merge(res,st[rr-(1<<k)+1][k]);
    }
    return res;
}

inline void decode(int &l, int &r, int &k, long long lstans, int testop) {
	lstans %= 19260817;
	if(testop) {
		l ^= lstans; l = (l % n + n) % n + 1;
		r ^= lstans; r = (r % n + n) % n + 1;
		if(l > r) std :: swap(l, r);
		k ^= lstans; 
		k = (k % std :: min(r - l + 1, 100)) + 1;
	}
}

ll lstans = 0;

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);

    int id,c;

    cin>>id;
    cin>>c>>n;
    for(int i=1,u,v,w;i<n;i++){
        cin>>u>>v>>w;
        AddEdge(u,v,w);
        AddEdge(v,u,w);
    }
    for(int i=1;i<=n;i++) cin>>p[i];

    DFS(1);
    InitLCA();
    Init();
    
    cin>>q;
    while(q--){
        int l,r,k;
        cin>>l>>r>>k;
        decode(l, r, k, lstans, c);
        vector<int> imp=Get(l,r);
        cout<<(lstans=Worth(imp,k))<<endl;
    }

    return 0;
}
```

# T3 - 度假岛

## 题面

### 题目大意

### 数据范围

题解

```cpp
#pragma GCC optimize(3)
#pragma GCC target("avx")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")

#include<bits/stdc++.h>

using namespace std;

ifstream fin("hswfwkj.in");
ofstream fout("hswfwkj.out");
#define cin fin
#define cout fout
#define endl '\n'

using ll=long long;
const int N=2e6+9;
const int lgN=2e1;

int a[N],ql[N],qr[N],n,q;
int mx[N][lgN],lg[N];
inline void Init(){
    for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
    for(int i=1;i<=n;i++) mx[i][0]=i;
    for(int k=1;k<=lg[n];k++){
        for(int i=1,x,y;i<=n;i++){
            x=mx[i][k-1],y=mx[i+(1<<k-1)][k-1];
            if(a[x]>a[y]) mx[i][k]=x;
            else mx[i][k]=y;
        }
    }
}
inline int MaxPoint(int l,int r){
    int k=lg[r-l+1],x=mx[l][k],y=mx[r-(1<<k)+1][k];
    return a[x]>a[y]?x:y;
}

struct SgT{
    struct Node{
        int l,r;
        ll sum,ktag,btag,ctag;
    }tr[N<<2];
    #define l(x) tr[x].l
    #define r(x) tr[x].r
    #define sum(x) tr[x].sum
    #define len(x) (r(x)-l(x)+1)
    #define ktag(x) tr[x].ktag
    #define btag(x) tr[x].btag
    #define ctag(x) tr[x].ctag

    inline void PushUp(int x){sum(x)=sum(x<<1)+sum(x<<1|1);}
    inline void PushLine(int x,ll k,ll b){
        ktag(x)+=k,btag(x)+=b;
        sum(x)+=k*(len(x)*(len(x)+1)/2)+b*len(x);
    }
    inline void PushCov(int x,ll c){
        ktag(x)=btag(x)=0;
        ctag(x)=c;
        sum(x)=c*len(x);
    }
    inline void PushDown(int x){
        if(~ctag(x)){
            PushCov(x<<1,ctag(x));
            PushCov(x<<1|1,ctag(x));
            ctag(x)=-1;
        }
        if(ktag(x)||btag(x)){
            PushLine(x<<1,ktag(x),btag(x));
            PushLine(x<<1|1,ktag(x),btag(x)+ktag(x)*len(x<<1));
            ktag(x)=btag(x)=0;
        }
    }
    inline void Build(int x,int l,int r){
        l(x)=l,r(x)=r,ctag(x)=-1,ktag(x)=btag(x)=0;
        if(l(x)==r(x)) return ;
        int mid=l(x)+r(x)>>1;
        Build(x<<1,l,mid),Build(x<<1|1,mid+1,r);
        PushUp(x);
    }
    inline void AddLine(int x,int l,int r,ll k,ll b){
        if(l<=l(x)&&r(x)<=r) return PushLine(x,k,b);
        int mid=l(x)+r(x)>>1;
        PushDown(x);
        if(l<=mid&&mid<r) AddLine(x<<1,l,mid,k,b),AddLine(x<<1|1,mid+1,r,k,b+k*(mid-l+1));
        else if(l<=mid) AddLine(x<<1,l,r,k,b);
        else AddLine(x<<1|1,l,r,k,b);
        PushUp(x);
    }
    inline void Cover(int x,int l,int r,ll c){
        if(l<=l(x)&&r(x)<=r) return PushCov(x,c);
        int mid=l(x)+r(x)>>1;
        PushDown(x);
        if(l<=mid) Cover(x<<1,l,r,c);
        if(r>mid) Cover(x<<1|1,l,r,c);
        PushUp(x);
    }
    inline ll Query(int x,int pos){
        if(pos<1||pos>n) return 0;
        if(l(x)==r(x)) return sum(x);
        int mid=l(x)+r(x)>>1;
        PushDown(x);
        if(pos<=mid) return Query(x<<1,pos);
        else return Query(x<<1|1,pos);
    }
    inline ll operator ()(int pos){return Query(1,pos);}
}f,g;

ll ans[N];
vector<int> v[N];
inline void Solve(int l,int r){
    if(l>r) return ;
    int mid=MaxPoint(l,r);
    Solve(l,mid-1),Solve(mid+1,r);
    for(int i:v[mid]){
        ll resl=g(ql[i])+1ll*(qr[i]-mid+1)*a[mid];
        ll resr=f(qr[i])+1ll*(mid-ql[i]+1)*a[mid];
        ans[i]=min(resl,resr);
    }
    ll fmid=f(mid-1),gmid=g(mid+1);
    f.Cover(1,mid,mid,mid>l?fmid+a[mid]:a[mid]);
    g.Cover(1,mid,mid,mid<r?gmid+a[mid]:a[mid]);
    if(r>mid){
        int lp=mid,rp=r+1;
        while(lp+1<rp){
            int midp=lp+rp>>1;
            ll lval=fmid+1ll*(midp-mid+1)*a[mid];
            ll rval=1ll*(mid-l+1)*a[mid]+f(midp);
            if(lval<=rval) lp=midp;
            else rp=midp;
        }
        if(lp>mid) f.Cover(1,mid+1,lp,fmid),f.AddLine(1,mid+1,lp,a[mid],a[mid]);
        if(rp<=r) f.AddLine(1,rp,r,0,1ll*(mid-l+1)*a[mid]);
    }
    if(l<mid){
        int lp=l-1,rp=mid;
        while(lp+1<rp){
            int midp=lp+rp>>1;
            ll lval=g(midp)+1ll*(r-mid+1)*a[mid];
            ll rval=1ll*(mid-midp+1)*a[mid]+gmid;
            if(rval<=lval) rp=midp;
            else lp=midp;
        }
        if(rp<mid) g.Cover(1,rp,mid-1,gmid),g.AddLine(1,rp,mid-1,-a[mid],1ll*a[mid]*(mid-rp+2));
        if(lp>=l) g.AddLine(1,l,lp,0,1ll*(r-mid+1)*a[mid]);
    }
}

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);

    cin>>n>>q;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=q;i++) cin>>ql[i]>>qr[i];

    Init();
    f.Build(1,1,n);
    g.Build(1,1,n);
    for(int i=1;i<=q;i++) v[MaxPoint(ql[i],qr[i])].push_back(i);
    Solve(1,n);

    for(int i=1;i<=q;i++) cout<<ans[i]<<endl;

    return 0;
}
```