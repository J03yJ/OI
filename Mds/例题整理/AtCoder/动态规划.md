## 神秘 DP

### ABC298G

$\tt\color{orange}Diff:2405$

#### 题目大意

给定一个 $N\times M$ 的矩阵，每个格子由权 $a_{i,j}$，现在要执行 $T$ 次操作，每次为以下两种操作之一：

- 选择一个矩阵，沿水平方向任意一条直线将其分为两个新矩阵。
- 选择一个矩阵，沿竖直方向任意一条直线将其分为两个新矩阵。

最后一共会有 $T+1$ 个矩阵，定义一个矩阵的权为其元素的权之和，令 $M$ 和 $m$ 分别为 $T+1$ 个矩阵中权的最大最小值，求最小的 $M-m$。

数据范围：

- $N,M\leq 6$
- $0\leq a_{i,j}\leq 10^{16}$

#### 题解

考虑枚举最小值，这是 $O(N^2M^2)$ 的，然后对于每个最小值 $m$ DP。

具体的，设 $f_{i,j,p,q,k}$ 表示对于矩形 $[i:p][j:q]$ 已经进行了 $k$ 次切割，这 $k+1$ 个矩形的最大值的最小值。枚举分界线进行转移，时间复杂度 $O(N^2M^2T^2(N+M))$。

总时间复杂度是 $O(N^4M^4T^2(N+M))$ 的，乍一看不能接受，但是常数十分的小，可以通过。

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long

const int N=9;
const int N2=3e1+9;

int a[N][N],s[N][N][N][N],f[N][N][N][N][N2],n,m,t;
vector<int> val;

inline void ChMin(int &x,int y){if(y<x) x=y;}
int Work(int lim){
    memset(f,0x3f,sizeof f);
    for(int il=1;il<=n;il++){
        for(int jl=1;jl<=m;jl++){
            for(int i=1;i<=n-il+1;i++){
                int p=i+il-1;
                for(int j=1;j<=m-jl+1;j++){
                    int q=j+jl-1;
                    if(s[i][j][p][q]>=lim) f[i][j][p][q][0]=s[i][j][p][q];
                    for(int sp=i;sp<p;sp++){
                        for(int x=1;x<=il*jl&&x<=t;x++){
                            for(int y=0;y<x;y++){
                                ChMin(f[i][j][p][q][x],max(f[i][j][sp][q][y],f[sp+1][j][p][q][x-y-1]));
                            }
                        }
                    }
                    for(int sp=j;sp<q;sp++){
                        for(int x=1;x<=il*jl&&x<=t;x++){
                            for(int y=0;y<x;y++){
                                ChMin(f[i][j][p][q][x],max(f[i][j][p][sp][y],f[i][sp+1][p][q][x-y-1]));
                            }
                        }
                    }
                }
            }
        }
    }
    return f[1][1][n][m][t];
}

signed main(){
    cin>>n>>m>>t;
    
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++) cin>>a[i][j];
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            for(int p=i;p<=n;p++){
                int sum=0;
                for(int q=j;q<=m;q++){
                    for(int k=i;k<=p;k++) sum+=a[k][q];
                    val.push_back(sum);
                    s[i][j][p][q]=sum;
                }
            }
        }
    }
    sort(val.begin(),val.end());
    val.erase(unique(val.begin(),val.end()),val.end());

    int ans=1e18;
    for(int x:val) ans=min(ans,Work(x)-x); 
    cout<<ans<<endl;

    return 0;
}
```

### AGC062B

$\tt\color{orange} Diff:2407$

#### 题目大意

给定一个排列 $A$，最初 $A_i=i$。接下来将执行以下操作 $K$ 次：

- 选定一个整数 $k$，使得 $0\leq k\leq N$，将 $A$ 替换为满足以下条件的任意排列 $A'$：
  - $A_1,...,A_{N-k}$ 是 $A'$ 的子序列。
  - $A_{N-k+1}...A_N$ 是 $A'$ 的子序列。

这样做的花费为 $\sum_{i=1}^K C_ik_i$。

问 $K$ 次操作后，$A$ 是否可能变成 $P$，若可能，则求出最小代价。

数据范围：

- $N,K\leq 100$
- $P$ 是一个长为 $N$ 的排列。

#### 题解

正难则反，考虑时光倒流。

令排列 $Q$ 为 $P$ 的逆，则问题变为每次可以使 $Q$ 的一个子序列垫底，问 $Q$ 变成 $A$ 的最小代价（因为 $A$ 的逆是 $A$ 本身）。

设 $f_{i,j,k}$ 表示操作完操作 $K\sim k$，且值域 $[i,j]$ 的数已经排好序（相对）的最小代价，转移有两种：

- $f_{i,j,k}\leftarrow f_{i,j,k+1}$：这一轮没有对 $[i,j]$ 操作。
- $f_{i,j,k}\leftarrow f_{i,p,k+1}+f_{p+1,j,k+1}+c_k(j-p)$：这一轮将 $[p+1,j]$ 置于 $Q$ 的最后，并完成了 $[i,j]$ 的排序。

边界：若 $[i,j]$ 在 $Q$ 中已经排好了，则 $f_{i,j,K+1}=0$。

单次转移是 $O(N)$ 的，总时间复杂度是 $O(N^3K)$。

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long
const int N=1e2+9;

int p[N],q[N],c[N],f[N][N][N],n,lim;
void ChMin(int &x,int y){if(y<x) x=y;}

signed main(){
    cin>>n>>lim;
    for(int i=1;i<=lim;i++) cin>>c[i];
    for(int i=1;i<=n;i++) cin>>p[i];
    for(int i=1;i<=n;i++) q[p[i]]=i;

    memset(f,0x3f,sizeof f);
    for(int i=1;i<=n;i++){
        f[lim+1][i][i]=0;
        for(int j=i+1;j<=n;j++){
            if(q[j]<q[j-1]) break ;
            f[lim+1][i][j]=0;
        }
    }
    for(int k=lim;k>=1;k--){
        for(int i=1;i<=n;i++){
            for(int j=i;j<=n;j++){
                f[k][i][j]=f[k+1][i][j];
                for(int p=i;p<j;p++){
                    ChMin(f[k][i][j],f[k+1][i][p]+f[k+1][p+1][j]+c[k]*(j-p));
                }
            }
        }
    }
    if(f[1][1][n]>1e18) cout<<-1<<endl;
    else cout<<f[1][1][n]<<endl;

    return 0;
}
```

### ABC282G

$\tt\color{orange} Diff:2412$

#### 题目大意

给定 $N,M,P$，定义长度为 $N$ 的两个排列 $A,B$ 的相似度为 $\displaystyle \sum_{i=1}^{n-1} [(A_i-A_{i+1})(B_i-B_{i+1})\gt 0]$。求排列对 $(A,B)$ 的个数模 $P$，使得 $A,B$ 的相似度为 $M$。

数据范围：

- $2\leq N\leq100$

- $0\leq M\lt N$
- $10^8\leq P\leq 10^9$

#### 题解

令 $f_{i,j,a,b}$ 表示当前考虑到第 $i$ 位，相似度为 $j$，且 $A_i$ 在 $A[1:i]$ 中的 rank 为 $a$，$B_i$ 在 $B[1:i]$ 中的 rank 为 $b$，那么显然可以 $O(N^6)$ 转移（枚举当前状态以及上一位取值）。

发现 $j$ 每次操作后至多增加 $1$，并且对 $j$ 的贡献可以按 $a,b$ 的大小分成 $4$ 个矩形，直接二维前缀和优化，时间复杂度 $O(N^4)$。

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=1e2+9;

int f[N][N][N][N],s[N][N][N][N],n,k,mod;
inline void AddAs(int &x,int y){x+=y;if(x>=mod) x-=mod;}
inline void SubAs(int &x,int y){x-=y;if(x<0) x+=mod;}
inline int F(int i,int j,int al,int ar,int bl,int br){
    if(al>ar||bl>br||j<0) return 0;
    int sum=s[i][j][ar][br];
    SubAs(sum,s[i][j][ar][bl-1]);
    SubAs(sum,s[i][j][al-1][br]);
    AddAs(sum,s[i][j][al-1][bl-1]);
    return sum;
}

int main(){
    cin>>n>>k>>mod;

    f[1][0][1][1]=s[1][0][1][1]=1;
    for(int i=2;i<=n;i++){
        for(int j=0;j<i;j++){
            for(int a=1;a<=i;a++){
                for(int b=1;b<=i;b++){
                    AddAs(f[i][j][a][b],F(i-1,j-1,1,a-1,1,b-1));
                    AddAs(f[i][j][a][b],F(i-1,j-1,a,i-1,b,i-1));
                    AddAs(f[i][j][a][b],F(i-1,j,1,a-1,b,i-1));
                    AddAs(f[i][j][a][b],F(i-1,j,a,i-1,1,b-1));
                }
            }
            for(int a=1;a<=i;a++){
                for(int b=1;b<=i;b++){
                    s[i][j][a][b]=f[i][j][a][b];
                    AddAs(s[i][j][a][b],s[i][j][a-1][b]);
                    AddAs(s[i][j][a][b],s[i][j][a][b-1]);
                    SubAs(s[i][j][a][b],s[i][j][a-1][b-1]);
                }
            }
        }
    }

    int ans=0;
    for(int a=1;a<=n;a++){
        for(int b=1;b<=n;b++){
            AddAs(ans,f[n][k][a][b]);
        }
    }
    cout<<ans<<endl;

    return 0;
}
```

## 用数据结构维护（优化）的 DP

### ABC340G

$\tt\color{orange} Diff:2401$

#### 题目大意

给定一棵大小为 $n$ 的树 $T$，每个点有一种颜色 $A_i$。求所有叶子节点颜色相同的 $T$ 的子树的数量，对 $998244353$ 取模。

数据范围：

- $n \leq 2 \times 10^5$
- $A_i\leq n$

#### 题解

对每种颜色分别考虑，设当前颜色为 $c$。考虑对其 dp，令 $f_u$ 代表所有以 $u$ 为根的除 $u$ 以外叶子节点颜色为 $c$ 的子树数量，则显然：

- 若 $A_u=c$，则有 $\displaystyle f_u=\prod _{v\in son_u} (f_v+1)$。

- 若 $A_u\neq c$，则有 $\displaystyle f_u=\prod _{v\in son_u} (f_v+1)-1$。

考虑 $u$ 对答案的贡献：

- 若 $A_u=c$，则 $u$ 对答案贡献为 $f_u$。

- 若 $A_u\neq c$，则 $u$ 对答案贡献为 $\displaystyle f_u-\sum _{v\in son_u} f_v$，因为 $u$ 不能是叶子节点。

所以答案为 $\displaystyle \sum _{u\in T} f_u-[A_u\neq c]\sum _{v\in son_u} f_v$，时间复杂度 $O(n^2)$。

发现所有含有小于两个颜色为 $c$ 的点的贡献为 $0$，所以我们考虑对颜色为 $c$ 的点建立虚树，由于虚树上最多有 $2n$ 个点，所以时间复杂度为 $O(n\log n)。$

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=2e5+9;
const int p=998244353;

namespace tr{
    int fi[N],ne[N<<1],to[N<<1],adj=1;
    void adeg(int x,int y){
        ne[++adj]=fi[x];
        fi[x]=adj;
        to[adj]=y;
    }

    int dep[N],fa[N],siz[N],hson[N];
    void dfs1(int x){
        siz[x]=1;
        for(int i=fi[x];i;i=ne[i]){
            int y=to[i];
            if(y==fa[x]) continue ;
            dep[y]=dep[x]+1;
            fa[y]=x;
            dfs1(y);
            siz[x]+=siz[y];
            if(siz[y]>siz[hson[x]]) hson[x]=y;
        }
    }
    int top[N],dfn[N],dcnt;
    void dfs2(int x,int t){
        top[x]=t;
        dfn[x]=++dcnt;
        if(hson[x]) dfs2(hson[x],t);
        else return ;
        for(int i=fi[x];i;i=ne[i]){
            int y=to[i];
            if(y==fa[x]) continue ;
            if(y==hson[x]) continue ;
            dfs2(y,y);
        }
    }
    int lca(int x,int y){
        while(top[x]!=top[y]){
            if(dep[top[x]]<dep[top[y]]) swap(x,y);
            x=fa[top[x]];
        }
        if(dep[x]>dep[y]) swap(x,y);
        return x;
    }
}

int a[N],n;
vector<int> c[N];

namespace vtr{
    int fi[N],ne[N<<2],to[N<<2],adj=1;
    void adeg(int x,int y){
        ne[++adj]=fi[x];
        fi[x]=adj;
        to[adj]=y;
    }

    bool imp[N];
    bool cmp(int x,int y){
        return tr::dfn[x]<tr::dfn[y];
    }
    vector<int> node;
    int build(vector<int> a){
        int n=a.size();
        sort(a.begin(),a.end(),cmp);
        for(int x:a) imp[x]=1;
        for(int i=1;i<n;i++) a.push_back(tr::lca(a[i-1],a[i]));
        sort(a.begin(),a.end(),cmp);
        n=unique(a.begin(),a.end())-a.begin();
        for(int i=1;i<n;i++) adeg(tr::lca(a[i-1],a[i]),a[i]);
        for(int i=0;i<n;i++) node.push_back(a[i]);
        return a[0];
    }
    long long f[N],ans;
    void dfs(int x,int col){
        f[x]=1;
        for(int i=fi[x];i;i=ne[i]){
            int y=to[i];
            if(tr::dfn[y]<tr::dfn[x]) continue ;
            dfs(y,col);
            f[x]=f[x]*(f[y]+1)%p;
        }
        if(a[x]!=col){
            f[x]=(f[x]+p-1)%p;
            long long res=f[x];
            for(int i=fi[x];i;i=ne[i]){
                int y=to[i];
                if(tr::dfn[y]<tr::dfn[x]) continue ;
                res=(res+p-f[y])%p;
            }
            ans=(ans+res)%p;
        }else ans=(ans+f[x])%p;
    }
    void clear(){
        for(int x:node) imp[x]=0,fi[x]=0,f[x]=0;
        node.clear();
        adj=1;
        ans=0;
    }
}

int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i],c[a[i]].push_back(i);
    for(int i=1;i<n;i++){
        int x,y;
        cin>>x>>y;
        tr::adeg(x,y);
        tr::adeg(y,x);
    }

    tr::fa[1]=1;
    tr::dfs1(1);
    tr::dfs2(1,1);

    long long res=0;
    for(int i=1;i<=n;i++){
        if(!c[i].size()) continue ;
        vtr::dfs(vtr::build(c[i]),i);
        res=(res+vtr::ans)%p;
        vtr::clear();
    }
    cout<<res<<endl;

    return 0;
}
```
